	.title	STCORE
	.enabl	LC, AMA ; (!) AMA is needed (!)

	.asect
	.=1000

@include common.mac

C_TAPES_NEEDED  =: 10.
C_NORMAL_ENERGY =: 1

; Special comments-warnings in the code:
; !!MUT-CMD!! - the command mutable, means other code changes it
; !!MUT-ARG!! - the command argument is mutable
; !!MUT-2ndARG!! - the command 2nd argument is mutable

	.macro	push	RR
	mov	RR, -(SP)
	.endm

	.macro	pop	RR
	mov	(SP)+, RR
	.endm

	.macro	.ppexe	X
	mov	X, @#PpuComm
	tst	@#PpuComm
	bne	.-4
	.endm

Start:	mtps	#200
	; prepare mirroring table
	call	PrepMirror
	; set PPU to process tiles buffer
	mov	#TileBuf/2, @#PpuData
	.ppexe	#C_PPU_INITILE
	; set VSync int (FpsMeter)
	mov	@#100, Bkp100
	mov	@#102, Bkp102
	mov	#VsyInt, @#100
	mov	#200, @#102
	; go go go
	mtps	#0
	jmp	CoreStart

; //////////////////////////////////////////////////////////////////////////////
; // Data
; //////////////////////////////////////////////////////////////////////////////

FramesCount:	.word	0

RocketLaunched:	.word	0
Energy:		.word	0
NinaOnFire:	.word	0
NinaCanShock:	.word	0

K01602:		.word	0

K01604:		.byte	0			; temp
K01605:		.byte	0
K01606:		.byte	0
K01607:		.byte	0

K01610:		.byte	0			; offset value in room marker processing
K01611:		.byte	0

; PANMS - Indicator signs
StrHeld:	.ascii	/HELD/
		.ascii	/ FPS /
		.ascii	/NEAR/
StrMoney:	.ascii	/ PAY $0000000 /
		.even

	.blkb	128.
ReflectionTable:
	.blkb	128.

FontData:
	.byte	000,000,000,000,000,000,000,000,000,154,222,202,202,104,050,020
	.byte	120,120,000,000,000,000,000,000,012,012,000,000,000,000,000,000
	.byte	000,020,174,024,174,120,174,020,377,377,173,377,267,375,377,000
	.byte	377,175,337,377,173,377,377,000,000,000,020,000,000,020,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,176,102,102,142,142,176,000,000,020,020,020,030,030,030,000
	.byte	000,176,100,100,176,006,176,000,000,176,100,170,140,140,176,000
	.byte	000,102,102,176,140,140,140,000,000,176,002,176,140,140,176,000
	.byte	000,176,002,176,142,142,176,000,000,176,100,100,140,140,140,000
	.byte	000,176,102,176,142,142,176,000,000,176,102,176,140,140,140,000
	.byte	000,000,010,000,000,010,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.byte	000,000,000,000,000,000,000,000,000,176,102,102,176,142,142,000
	.byte	000,076,102,076,142,142,076,000,000,176,002,002,006,006,176,000
	.byte	000,076,102,102,142,142,076,000,000,176,002,176,006,006,176,000
	.byte	000,176,002,176,006,006,006,000,000,176,102,002,162,142,176,000
	.byte	000,102,102,176,142,142,142,000,000,020,020,020,030,030,030,000
	.byte	000,100,100,100,142,142,176,000,000,102,102,176,062,062,062,000
	.byte	000,002,002,002,002,002,176,000,000,176,112,112,152,152,152,000
	.byte	000,116,112,112,152,152,172,000,000,176,102,102,142,142,176,000
	.byte	000,176,102,102,176,006,006,000,000,176,102,102,162,162,376,340
	.byte	000,176,102,102,176,062,062,000,000,176,002,176,140,140,176,000
	.byte	000,176,020,020,030,030,030,000,000,102,102,102,142,142,176,000
	.byte	000,102,102,102,064,064,030,000,000,112,112,112,152,152,176,000
	.byte	000,102,044,030,030,064,142,000,000,102,102,176,030,030,030,000
	.byte	000,176,100,176,006,006,176,000

; items addrs - Nothing, Shuriken, Knife, Empty Box, Question, Pipe, Question, Wrench
ItemsPicTbl:
	.word	K05274, K05450, K05624, K06000, K06154, K06504, K06154, K06330

; items data 32x24, 108. bytes each * 7 = 756. bytes total
K05274:	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,322,273,124,172,126,222,324,112,126,222,324,012
	.BYTE	136,222,327,153,132,222,124,113,132,222,124,113,322,223,124,172
	.BYTE	000,000,000,000,000,000,000,000,360,360,360,360
K05450:	.BYTE	000,000,000,000,000,000,001,000,000,000,001,000,000,000,001,000
	.BYTE	000,200,001,000,000,200,001,000,000,300,003,000,000,376,017,000
	.BYTE	000,360,177,000,000,300,003,000,000,200,001,000,000,200,001,000
	.BYTE	000,200,000,000,000,200,000,000,000,200,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,256,152,252,113,242,252,252,130
	.BYTE	356,152,232,171,250,252,252,150,256,244,252,113,000,000,000,000
	.BYTE	000,242,340,000,000,342,240,000,360,360,360,360
K05624:	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,007,000,003,300,003
	.BYTE	200,000,360,000,200,000,074,000,200,000,017,000,200,300,003,000
	.BYTE	200,360,000,000,200,074,000,000,200,017,000,000,300,003,000,000
	.BYTE	360,003,000,000,374,006,000,000,076,030,001,000,016,340,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	140,140,342,342,140,342,342,342,140,140,140,140
K06000:	.BYTE	000,300,003,000,000,100,003,000,000,100,003,000,000,100,003,000
	.BYTE	000,360,017,000,000,240,007,000,000,100,003,000,000,200,001,000
	.BYTE	377,377,377,377,377,377,377,377,000,000,000,000,024,000,000,050
	.BYTE	022,000,000,110,360,377,377,017,120,125,125,015,120,125,125,015
	.BYTE	000,000,000,000,322,273,124,172,126,222,324,112,126,222,324,012
	.BYTE	136,222,327,153,132,222,124,113,132,222,124,113,322,223,124,172
	.BYTE	040,040,040,040,014,014,014,014,360,360,360,360
K06154:	.BYTE	000,000,000,000,000,340,007,000,000,270,036,000,000,124,065,000
	.BYTE	000,002,150,000,000,302,121,000,000,044,142,000,000,030,124,000
	.BYTE	000,000,144,000,000,000,062,000,000,000,051,000,000,200,024,000
	.BYTE	000,100,012,000,000,040,005,000,000,240,002,000,000,040,003,000
	.BYTE	000,340,003,000,000,000,000,000,000,300,001,000,000,140,003,000
	.BYTE	000,240,002,000,000,040,003,000,000,300,001,000,000,000,000,000
	.BYTE	302,302,302,302,302,302,302,302,302,302,302,302
K06330:	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,034
	.BYTE	000,000,000,076,000,000,000,007,000,000,300,007,000,000,160,047
	.BYTE	000,000,334,077,000,000,367,034,000,300,075,000,000,160,017,000
	.BYTE	000,334,003,000,360,366,000,000,370,075,000,000,310,017,000,000
	.BYTE	300,003,000,000,300,001,000,000,370,000,000,000,160,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,242,240,242,242,240,242,240,242,000,000
K06504:	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,376,377,377,177,372,376,377,177
	.BYTE	372,340,360,160,002,000,000,100,376,377,377,177,000,000,000,000
	.BYTE	000,000,000,000,000,000,000,000,000,000,000,000,000,000,000,000
	.BYTE	000,000,000,000,176,176,176,176,306,030,306,006,306,030,306,176
	.BYTE	176,030,176,006,006,030,006,006,006,176,006,176,000,000,000,000
	.BYTE	342,342,340,340,242,242,240,240,360,360,360,360

; guard tiles
; 243..245 - flamethrower
; (!!!) they are +1 in this table
GuardTilesAttr:
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 000 - 020
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 020 - 040
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 040 - 060
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 060 - 100
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 100 - 120
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 120 - 140
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 140 - 160
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 160 - 200
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 200 - 220
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 220 - 240
	.byte	0, 0, 0, 0, 2, 2, 2, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 240 - 260
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 260 - 300
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 300 - 320
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 320 - 340
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 340 - 360
	.byte	0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 360 - 400
; (waste of memory to color only flamethrower, but alas..)

; waste of memory too ^_^
; 117 - 125 - electric fence
ElectroTbl:
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 000 - 020
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 020 - 040
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 040 - 060
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 060 - 100
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0,20 ; 100 - 120
	.byte	20,20,20,20,20,20, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 120 - 140
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 140 - 160
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 160 - 200
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 200 - 220
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 220 - 240
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 240 - 260
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 260 - 300
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 300 - 320
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 320 - 340
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 340 - 360
	.byte	 0, 0, 0, 0, 0, 0, 0, 0,  0, 0, 0, 0, 0, 0, 0, 0 ; 360 - 400

; table for auto-masking tiles
        .byte   300, 303, 307, 307, 316, 317, 317, 317, 334, 337, 337, 337, 336, 337, 337, 337
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   360, 363, 367, 367, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   340, 343, 347, 347, 356, 357, 357, 357, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   360, 363, 367, 367, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
MaskTable:
        .byte   000, 003, 007, 007, 016, 017, 017, 017, 034, 037, 037, 037, 036, 037, 037, 037
        .byte   070, 073, 077, 077, 076, 077, 077, 077, 074, 077, 077, 077, 076, 077, 077, 077
        .byte   160, 163, 167, 167, 176, 177, 177, 177, 174, 177, 177, 177, 176, 177, 177, 177
        .byte   170, 173, 177, 177, 176, 177, 177, 177, 174, 177, 177, 177, 176, 177, 177, 177
        .byte   340, 343, 347, 347, 356, 357, 357, 357, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   360, 363, 367, 367, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377
        .byte   370, 373, 377, 377, 376, 377, 377, 377, 374, 377, 377, 377, 376, 377, 377, 377

MsgClr:	.asciz	<33>"%!3"<14>
	.even


; //////////////////////////////////////////////////////////////////////////////
; // Utils
; //////////////////////////////////////////////////////////////////////////////

; LFSR 8-bit random (Galois), 2^8-1 cycle
; cycle xor: 8-bit [10111000] 9-bit [110110000]
Random:	asr	#123
	bcc	30$
	mov	#^B0000000010111000, R0
	xor	R0, Random+2
30$:	mov	Random+2, R0
	return


; Preparing reflection table, but starting from 128.
PrepMirror:
	mov	#200, R4			; ^B10000000 = 200 = 128.
	clr	R0
	mov	#400, R1			; 256.
	mov	#ReflectionTable-200, R3	; REFBF table address
10$:	movb	#10, R2				; <  8.
	clr	R5
	bisb	R4, R5
20$:	rorb	R5				; | <
	rolb	R0				; | |
	sob	R2, 20$				; | repeat
	movb	R0, (R3)+
	incb	R4
	sob	R1, 10$				; repeat
	return


; EXX procedure R1 R2 R3 <-> R1' R2' R3'
; TODO: rework, used only in one place
ExTmp7:	.blkw	7
ExxPro:	push	R4
	mov	#ExTmp7, R4
	tst	(R4)
	bne	20$
	mov	SP, (R4)+
	mov	R1, (R4)+
	mov	R2, (R4)+
	mov	R3, (R4)+
	mov	(R4)+, R1
	mov	(R4)+, R2
	mov	(R4)+, R3
10$:	pop	R4
	return
20$:	add	#14., R4
	mov	R3, -(R4)
	mov	R2, -(R4)
	mov	R1, -(R4)
	mov	-(R4), R3
	mov	-(R4), R2
	mov	-(R4), R1
	clr	-(R4)
	br	10$


; to call Print as: call PrinSP, .word coords
PrinSP:	mov	@0(SP), R2
	add	#2, (SP)

; print procedure, R3 - string, R1 - length, R2 - screen coords
; TODO: better coords as [Y X]
PrintStr:
	push	R2
	push	R4
	push	R5
	call	ScrToVaddr			; screen coords R2 to screen address (R4)
PrintStrVaddr:
	mov	#176640, R4
	mov	#176642, R5
	mov	R2, (R4)
10$:	movb	(R3)+, R0			; string chars are < 128.
	beq	90$				; exit from zero terminated, screw R1
	asl	R0
	asl	R0
	asl	R0				; *8 bytes
	add	#FontData-256., R0		; + font base addr minus 256. for 32. symbols
	.rept	8.
	movb	(R0)+, (R5)			; font byte
	add	#C_SCRWID, (R4)
	.endr
	sub	#8.*C_SCRWID-1, (R4)		; advance vaddr
	sob	R1, 10$
90$:	pop	R5
	pop	R4
	pop	R2
	return

; screen coords R2 to screen address
; [0  1  0  Y7 Y6 Y2 Y1 Y0 | Y5 Y4 Y3 X4 X3 X2 X1 X0]
; игнорируем Y2 Y1 Y0 (всЄ кратно 8)
ScrToVaddr:
	mov	R2, R5
	bic	#^B1111111111100000, R2
	bic	#^B1110011100011111, R5
	swab	R5
	asrb	R5
	asrb	R5
	asrb	R5
	swab	R5
	ash	#-5, R5
	mul	#C_SCRWID*8., R5
	add	R5, R2
	add	#SCRTOP, R2
	return


; draw energy bar
; can use R0..R3
DrawEnergy:
	push	R4
	push	R5
	mov	#176640, R4
	mov	#176642, R5
	mov	#168.*C_SCRWID+6.+SCRTOP, (R4)	; initial vaddr
	; draw integral part if needed
	mov	Energy, R1
	asr	R1				; skip fractional part
	asr	R1
	asr	R1
	mov	R1, -(SP)			; (!) save for later use
	beq	10$				; nothing to draw
	mov	#177777, R0			; red color
	call	DrawEnergyCol
10$:	; draw fractional part if needed
	mov	Energy, R1
	bic	#^B1111111111111000, R1
	beq	20$				; nothing to draw
	asl	R1
	mov	EnergyFrac(R1), R0		; red/black stripe
	mov	#1, R1				; only one column
	call	DrawEnergyCol
	inc	(SP)				; increase as if it was integer part
20$:	; draw black part if needed
	mov	(SP)+, R1
	sub	#14., R1
	neg	R1
	ble	99$
	clr	R0
	call	DrawEnergyCol
99$:	pop	R5
	pop	R4
	return

; draw R1 vertical columns and advance (R4) (vaddr)
DrawEnergyCol:
10$:	mov	#8., R3
20$:	mov	R0, (R5)
	add	#C_SCRWID, (R4)
	mov	R0, (R5)
	add	#C_SCRWID, (R4)
	sob	R3, 20$
	sub	#16.*C_SCRWID-1, (R4)
	sob	R1, 10$
	return

EnergyFrac:	.word	^B0000000000000000
		.word	^B0000000100000001
		.word	^B0000001100000011
		.word	^B0000011100000111
		.word	^B0000111100001111
		.word	^B0001111100011111
		.word	^B0011111100111111
		.word	^B0111111101111111
		.word	^B1111111111111111

; energy up 1 point
EnergyUp:
	cmp	Energy, #14.*8.
	bge	99$
	push	R4
	push	R5
	mov	#176640, R4
	mov	#176642, R5
	inc	Energy
	; draw fractional (if any)
	mov	Energy, R1
	mov	R1, R2
	asr	R2
	asr	R2
	asr	R2
	add	#168.*C_SCRWID+6.+SCRTOP, R2
	mov	R2, (R4)
	bic	#^B1111111111111000, R1
	beq	20$				; nothing to draw
	asl	R1
	mov	EnergyFrac(R1), R0		; red/black stripe
10$:	mov	#1, R1				; only one column
	call	DrawEnergyCol
	br	90$
20$:	; draw integral (if any)
	dec	(R4)
	mov	#177777, R0
	br	10$
90$:	pop	R5
	pop	R4
99$:	return


; /////////////////////////////////////////////
; DOPIC procedure: Show the room on the screen
; /////////////////////////////////////////////

; BuffD bytes: 2 (draw) -> 1 (still draw) -> 0 (do not draw)

DrawScreen:
	; check STOP key here
	bit	#200, @#PpuKeys
	beq	10$
	jmp	CoreStart
10$:	; check FIRE key here
	bit	#P_KEY_FIRE, @#PpuKeys
	bne	20$
	clr	UseTerminal+2
20$:	; draw then
	inc	FramesCount
	clr	NinaOnFire
	clr	NinaCanShock
	mov	#BuffD, R5			; R5 - addr in BuffD (!) do not touch it
DrawScrCycle:
	mov	(R5), R0			; (!) WORD size
	bne	DrawScrWord
	inc	R5
	inc	R5
DrawScrCont:
	cmp	#TILES_DX*TILES_DY+BuffD, R5
	bhi	DrawScrCycle
DrawScrFin:
	mov	NinaOnFire, R1			; check hit by flames
	beq	10$
	call	Decen
10$:	return
DrawScrWord:
	tstb	R0
	beq	10$
	call	TBufBgr
	decb	(R5)
10$:	inc	R5
	tstb	(R5)
	beq	20$
	call	TBufBgr
	decb	(R5)
20$:	inc	R5
	br	DrawScrCont


; background tile
TBufBgr:
	clr	R1
	bisb	BuffB-BuffD(R5), R1		; get tile from BUFFB: Back tile screen
	mov	R1, R2
	movb	ElectroTbl(R1), NinaCanShock	; Nina can be shocked with some background
	mul	#10., R1			; tile is 10. bytes
	add	#BackTiles, R1
	; advance tile buf addr
	mov	TileBufAddr, R3			; PIX buffer address
	add	#12., R3			; 12. bytes for tile data
	cmp	R3, #TileBufEnd
	blo	10$
	mov	#TileBuf, R3
10$:	mov	R3, TileBufAddr
	; wait for PPU to finish if not
	tst	(R3)
	bpl	.-2
	; put background
	tst	(R3)+				; skip screen index
	mov	(R1)+, (R3)+
	mov	(R1)+, (R3)+
	mov	(R1)+, (R3)+
	mov	(R1)+, (R3)+
	mov	(R1)+, (R3)+			; last byte is attr
;	; check if we need to go further - some tiles are counted as foreground
	cmp	R2, #361
	blo	TBufGuard1
	jmp	TBufFore


; guard 1
TBufGuard1:
	clr	TOvClr				; clear tile color bis value
	clr	R1
	bisb	BuffG1-BuffD(R5), R1
	incb	R1
	beq	TBufGuard2
	movb	GuardTilesAttr(R1), TOvClr	; add guard 1 tiles color attribute
	asl	R1
	asl	R1
	asl	R1
	add	#GuardTiles-8., R1
	movb	Guard1Dir, TOvDir		; set guard 1 DIR
	call	TileOver

; guard 2
TBufGuard2:
	clr	R1
	bisb	BuffG2-BuffD(R5), R1
	incb	R1
	beq	TBufNina
	asl	R1
	asl	R1
	asl	R1
	add	#GuardTiles-8., R1
	movb	Guard2Dir, TOvDir		; set guard 2 DIR
	call	TileOver

; Nina
TBufNina:
	clr	R1
	bisb	BuffN-BuffD(R5), R1
	incb	R1
	beq	TBufFore
	add	TOvClr, NinaOnFire		; if were flamethrower - add it 
	add	NinaCanShock, NinaOnFire	; if on electric fence - add it too
	asl	R1
	asl	R1
	asl	R1
	add	#NinaTiles-8., R1
	movb	K36264, TOvDir			; set Nina DIR
	call	TileOver

; foreground tile
TBufFore:
	clr	R1
	bisb	BuffO-BuffD(R5), R1		; R1 - foreground tile #
	incb	R1				; +1 (!)
	beq	TBufOut				; was 377 - skip foreground
	cmp	R1, #345			; is it 'font' tile?
	bhis	TBufPrint			; yes
	; draw usual foreground tile, R1 - tile # + 1
	cmp	R1, #C_EMPTY_FORE+1
	beq	TBufOut
	mul	#18., R1			; tile is 9 words
	add	#ForeTiles-18., R1		; get fore tiles addr (compensate for +1)
	mov	TileBufAddr, R2
	tst	(R2)+				; skip screen index word
	.rept	4.
	bic	(R1)+, (R2)
	bis	(R1)+, (R2)+
	.endr
	mov	(R1), (R2)			; ZX attr

; output TilBuf to actual screen (PPU will do that)
TBufOut:
	mov	R5, R0
	sub	#BuffD, R0
	mov	R0, @TileBufAddr		; set screen index (PPU will start draw it then)
	return

; some foreground tiles are printable characters
; R1 - foreground tile # + 1
TBufPrint:
	asl	R1
	asl	R1
	asl	R1
	add	#FontData-1568.-8., R1		; + computerized font base address
	mov	TileBufAddr, R2			; PIX buffer address
	tst	(R2)+				; skip screen index word
	mov	(R1)+, (R2)+
	mov	(R1)+, (R2)+
	mov	(R1)+, (R2)+
	mov	(R1)+, (R2)+
	mov	#060, (R2)+			; black on yellow color
	br	TBufOut				; => DRAW


; out tile with auto-masking and reflection
; R1 - source addr, TOvDir - direction
TileOver:
	mov	TileBufAddr, R2
	tst	(R2)+				; skip screen index word
	; use C as flag for DIR
	tst	(PC)+				; check DIR (also clears C)
TOvDir:	.word	0
	beq	.+4
	sec					; use mirroring then
	.rept	8.
	movb	(R1)+, R0			; R1 - tile byte
	bcc	.+6				; skip mirroring if needed
	movb	ReflectionTable(R0), R0		; mirror tile byte
	bicb	MaskTable(R0), (R2)		; apply auto-mask
	bisb	R0, (R2)+			; apply tile
	.endr
	bic	#^B1111111111000111, (R2)	; always clear 'ink' (to black color)
	bis	(PC)+, (R2)			; set 'ink' if needed
TOvClr:	.word	0
	return


; print string on background tiles buffer, R2 - string, R1 - length, R3 - buf addr 
PrintOnBgr:
	mov	R1, -(SP)
10$:	movb	(R2)+, R0
	add	#244, R0			; 228.-64.
	movb	R0, (R3)+
	sob	R1, 10$
	sub	#2200, R3			; BUFFO-BUFFD (go to 'were changes' buffer)
	mov	(SP)+, R1
20$:	incb	-(R3)				; mark tile as 'was changed'
	sob	R1, 20$
	return


; 
TileBufAddr:	.word	TileBuf		; current tile buf addr 
TileBuf:	.blkb	C_TILES_PPU*12.	; buffer for 16 tile data: [index word] [0..7 data bytes] [zx attr word]
TileBufEnd:


; NERDR procedure: Update NEAR indicator
DrawNear:
	push	R3
	tstb	R0
	bne	20$
	mov	#K24762, R3
	tstb	(R3)
	beq	20$
	decb	(R3)
	mov	K23746, R3			; get NERST
	mov	#5, R1
10$:	bicb	#^B10000000, (R3)+
	sob	R1, 10$				; repeat
	call	L10300				; print money?
	clr	R0
20$:	mov	#32, R3				; X shift to draw item (near)
	br	DrawItem			; draw NEAR item

; draw HELD item
DrawHeld:
	movb	K33464, R0			; get HELD value
	push	R3
	clr	R3				; draw HELD

; draw HELD or NEAR item, R0 - item #, R3 - X 000 for HELD, 026 for NEAR
; (!) extra pop R3 from stack
DrawItem:
	push	R1
	push	R2	
	mov	#176640, R4
	mov	#176642, R5
	bic	#^B1111111111111000, R0
	asl	R0
	mov	ItemsPicTbl(R0), R2		; get item address
	add	#152.*C_SCRWID+SCRTOP+1, R3	; HELD item screen address + offset
	mov	R3, (R4)
	mov	#24., R1
10$:	.rept	4
	movb	(R2)+, (R5)
	inc	(R4)
	.endr
	add	#C_SCRWID-4., (R4)
	sob	R1, 10$	
	mov	#3, R5 				; TODO: ??? what's this
	pop	R2
	pop	R1
	pop	R3
	return


; Vsync interrupt
Bkp100:	.word	0
Bkp102:	.word	0
VsyInt:	; count #1
 	inc	(PC)+
VsyCnt:	.word	0
	; count #2
	inc	(PC)+
VsyGme:	.word	0
	; check for 10-sec
	cmp	VsyCnt, #500.
	blo	VsyRti
	; output FPS (in game mode)
	tst	(PC)+
FpsOut:	.word	0
	beq	VsyRti
	call	FpsOutput
	clr	FramesCount
	clr	VsyCnt	
VsyRti:	rti


; Fps output
FpsOutput:
	mov	R0, -(SP)
	mov	R1, -(SP)
	mov	R2, -(SP)
	mov	R4, -(SP)
	mov	R5, -(SP)
	mov	#176640, R4
	mov	#176642, R5
	mov	(R4), -(SP)
	;
	mov	#144.+16.*C_SCRWID+24.+SCRTOP, (R4)
	mov	FramesCount, R0
	cmp	R0, #999.
	blos	10$
	mov	#999., R0
10$:	mov	#3, R2
20$:	mov	R0, R1
	clr	R0
	div	#10., R0			; R1 = R0:R1 mod 10.
	call	DrawDigit
	sub	#8.*C_SCRWID+1, (R4)
	sob	R2, 20$
	;
	mov	(SP)+, (R4)
	mov	(SP)+, R5
	mov	(SP)+, R4
	mov	(SP)+, R2
	mov	(SP)+, R1
	mov	(SP)+, R0
	return


; draw one digit, R1 - 0..9, (R4) - vaddr, R5 - #176642
DrawDigit:
	asl	R1
	asl	R1
	asl	R1
	add	#FontData+128., R1
	.rept	8.
	movb	(R1)+, (R5)
	add	#C_SCRWID, (R4)
	.endr
	return


; Clear buffers
; BUFCL procedure: Fill Ninja tile screen
ClearBuffNina:
	mov	#BuffN, R0			; BUFFN Ninja tile screen address
	mov	#000110, R1			; 72. * 4 = 288. words
ClearBuff:	
	mov	#177777, R2			; filler
10$:	mov	R2, (R0)+			; <
	mov	R2, (R0)+
	mov	R2, (R0)+
	mov	R2, (R0)+
	sob	R1, 10$				; repeat
	return
; BUFC2 procedure: Fill Enemy 0/1 tile screens
ClearBuffGuards:	
	mov	#BuffG1, R0			; BUFG1 Enemy 0 tile screen address
	mov	#000220, R1			; 144.
	br	ClearBuff			; fill Enemy 0/1 tile screens


bIsDrawBuf1:	.byte	0
bIsDrawBuf2:	.byte	0

; DRWOB procedure
; put object on buffers
; R0 = K36210 - ??? (10. by default)
; R1 - DY, R2 - tiles seq, R3 - addr in buffX, K01604 - DX
; 047660
DrawObject:
	MOVB	R0, (PC)+
K47662:	.word	0
	MOVB	R0, (PC)+
K47666:	.word	0
	;
K47670:	PUSH	R4
	PUSH	R5
	tstb	K36264				; DIR
	bne	K55302				; => DROBR	
	; check if we are updating ManBf of BuffX
	; replace code accordingly
	; (копец затычки какие-то вставл€ю, переписать надо всЄ нафиг)
	mov	#K47774, R5			; where to copy code
	mov	#DrCMan, R4
	mov	#BuffB, K47726
	tstb	bIsDrawBuf1
	beq	30$				; updating ManBf
	mov	#DrCBuf, R4			; else updating BuffX
	mov	#BuffD, K47726
30$:	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	; 
	MOV	R1, R5				; R5 <- DY
	MOV	#ManBf, R1			; MANBF addr
K47720 =: .+2
	MOV	K36212, R4			; get MANPS
K47726 =: .+2
	ADD	#BuffB, R4			; BUFFB Back tile screen address
	MOVB	K01604, K50062			; DX
; LOOP6:
K47734:	MOVB	K50062, K01604
	PUSH	R4
	MOVB	K47662, K01606
	PUSH	R3
	; --- cycle by X
K47754:	CMPB	K01606, #040			; compare to 32.
	BHIS	K50010				; => NBUNG
	CMPB	K01607, #022			; compare to 18.
	BHIS	K50010				; => NBUNG
	; changeable code
K47774:	nop
	nop
	nop
	nop
	nop
	nop
	nop
K50010:	INCB	K01606
	INC	R4
	INC	R1
	INC	R3
	INC	R2
	DECB	K01604
	BNE	K47754				; => LOOP7
	; --- cycle by X
	POP	R3
	ADD	#000040, R3			; + 32.
	INCB	K01607
	POP	R4
	ADD	#000040, R4			; + 32.
	SOB	R5, K47734			; repeat => LOOP6
	POP	R5
	POP	R4
	RETURN

; DROBR
; facing left, R3 in BufFD, R4,R5 pushed already on stack
K55302:	; check if we are updating ManBf of BuffX
	; replace code accordingly
	; (копец затычки какие-то вставл€ю, переписать надо всЄ нафиг)
	mov	#K55372, R5			; where to copy code
	mov	#DrCMan, R4
	mov	#BuffB, K55322
	tstb	bIsDrawBuf2
	beq	30$				; updating ManBf
	mov	#DrCBuf, R4			; else updating BuffX
	mov	#BuffD, K55322
30$:	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	mov	(R4)+, (R5)+
	; 
	MOV	R1, R5
; PUM06:
K55312 =: .+2
K55310:	MOV	#ManBf+5, R1
K55316 =: .+2
	MOV	K36212, R4			; get MANPS
K55322 =: .+2
	ADD	#BuffB, R4			; BUFFB Back tile screen address
	MOVB	K01604, K55464
K55334 =: .+2
	ADD	#5, R2
; LROP6:
K55336:	MOVB	K55464, K01604			; <
	MOVB	K47666, K01606
K55352:	CMPB	K01606, #40			; 32.
	BHIS	K55406
	CMPB	K01607, #22			; 18.
	BHIS	K55406
K55372:	nop
	nop
	nop
	nop
	nop
	nop
	nop
K55406:	INCB	K01606
	INC	R4
	DEC	R1
	INC	R3
	DEC	R2
	DECB	K01604
	BNE	K55352
K55432 =: .+2
	ADD	#000032, R3
K55436 =: .+2
	ADD	#000014, R2			; 12.
	INCB	K01607
K55446 =: .+2
	ADD	#000032, R4
K55452 =: .+2
	ADD	#000014, R1			; 12.
	SOB	R5, K55336			; repeat => LROP6
	POP	R5
	POP	R4
	RETURN

; insert into 'changeable code'
DrCBuf:	; code to copy to screen buffers (16)
	movb	(R2), R0			; 2
	cmpb	R0, #377			; 4
	beq	.+10				; 2
	movb	R0, (R3)			; 2 update buffer (BuffN, BuffG1 etc.)
	movb	#2, (R4)			; 4 update BuffD
DrCMan:	; code to copy to ManBf (16)
	movb	(R4), (R1)			; 2
	br	.+14				; 2
	nop					; 2
	nop					; 2
	nop					; 2
	nop					; 2
	nop					; 2

K55464:	.word	6				; temp vars in drawing
K50062:	.word	6


; //////////////////////////////////////////////////////////////////////////////
; // PPU exch
; //////////////////////////////////////////////////////////////////////////////

; channel 2 data
PPmsg:	.word	PPArr
        .word	177777
PPArr:	.byte	0				; 23334 return value (0 - OK)
PPCmd:	.byte	2				; 23335 command (2 - release mem)
PPDev:	.word	32				; 23336 device type (0x-FD, 32-ppu mem)
PPApp:	.word	0				; 23340 argument(s) (PPU addr for mem operations)
PPAcp:	.word	0				; 23342 CPU addr (length in words for mem allocate)
PPLen:	.word	0				; 23344 length in words

; send to PPU by channel 2
PPSen:	mov	#PPMsg, R2
	mov	#5, R3
	br	20$
10$:	movb	(R2)+, @#176676
20$:	tstb	@#176674
	bpl	20$
	sob	R3, 10$
	return

; release PPU mem
PpuRelease:
	mov	PpuAddr, PPApp
	br	PpSen


; //////////////////////////////////////////////////////////////////////////////
; // Panel draw
; //////////////////////////////////////////////////////////////////////////////

DrawPanel:
	mov	#176640, R4
	mov	#176642, R5
	mov	#144.*C_SCRWID+SCRTOP, (R4)
	mov	#PanelTiles, R0
	mov	#6., R3
10$:	mov	#32., R2
20$:	movb	(R0)+, R1
	call	DrawPanelTile
	sob	R2, 20$
	add	#C_SCRWID*8.-32., (R4)
	sob	R3, 10$
	return
	
; draw one tile, R1 = #, (R4) - vaddr
DrawPanelTile:
	mul	#16., R1
	add	#PanelTile000, R1
	.rept	8.
	mov	(R1)+, (R5)
	add	#C_SCRWID, (R4)
	.endr
	sub	#C_SCRWID*8.-1, (R4)
	return

PanelTiles:
	.byte	0, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 1, 2, 1, 1, 1, 1, 3
	.byte	4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 6, 7, 7, 7, 10, 4, 5, 5, 5, 5, 4
	.byte	4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 11, 5, 5, 5, 12, 4, 5, 5, 5, 5, 4
	.byte	4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 13, 14, 14, 14, 15, 4, 5, 5, 5, 5, 4
	.byte	4, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 5, 4, 5, 5, 5, 5, 4
	.byte	16, 1, 1, 1, 1, 17, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 17, 1, 1, 1, 1, 1, 17, 1, 1, 1, 1, 20
	.even	

PanelTile000:
	.word	0, 44110, 130260, 155733, 46114, 112224, 22044, 2004
PanelTile001:
	.word	0, 102204, 42104, 57537, 164350, 44110, 42104, 0
PanelTile002:
	.word	0, 42104, 22044, 161342, 31463, 53126, 44511, 4010
PanelTile003:
	.word	0, 6014, 1002, 61142, 11423, 6415, 74571, 12024
PanelTile004:
	.word	4010, 76174, 11022, 10020, 4010, 37076, 44110, 6014
PanelTile005:
	.word	0, 0, 0, 0, 0, 0, 0, 0
PanelTile006:
	.word	0, 170000, 4000, 162000, 11000, 5000, 5000, 5000
PanelTile007:
	.word	0, 177400, 0, 177400, 0, 0, 0, 0
PanelTile008:
	.word	0, 7400, 10000, 23400, 44000, 50000, 50000, 50000
PanelTile009:
	.word	5000, 5000, 5000, 5000, 5000, 5000, 5000, 5000
PanelTile010:
	.word	50000, 50000, 50000, 50000, 50000, 50000, 50000, 50000
PanelTile011:
	.word	5000, 5000, 5000, 11000, 162000, 4000, 170000, 0
PanelTile012:
	.word	0, 0, 0, 0, 177400, 0, 177400, 0
PanelTile013:
	.word	50000, 50000, 50000, 44000, 23400, 10000, 7400, 0
PanelTile014:
	.word	4010, 114230, 107617, 146314, 172364, 41102, 41102, 20040
PanelTile015:
	.word	4010, 125252, 135272, 152324, 43507, 42104, 21042, 0
PanelTile016:
	.word	74170, 12024, 14431, 15433, 23046, 21042, 42104, 2004


; //////////////////////////////////////////////////////////////////////////////
; // Rocket Launch
; //////////////////////////////////////////////////////////////////////////////

RocketLaunch:
	return


; //////////////////////////////////////////////////////////////////////////////
; // START
; //////////////////////////////////////////////////////////////////////////////

CoreStart:	
	; reset 
	mov	#1000, SP

	; title screen
	clr	FpsOut				; disable showing FPS
	.ppexe	#C_PPU_PALETTE1			; show title screen
	.ppexe	#C_PPU_MUSIC0			; init title music
	clr	@#PpuKeys	
10$:	; vsync
	tst	VsyCnt
	beq	10$
	clr	VsyCnt
	.ppexe	#C_PPU_PLAY
	; check keys
	mov	@#PpuKeys, R0
	beq	10$
	clr	PpuKeys
	.ppexe	#C_PPU_MUTE			; mute music
	.ppexe	#C_PPU_PALETTE2

	; STOP was pressed?
	bit	#200, R0
	beq	AfterTitle

	; exit to RT-11 or whatever..
	mtps	#200
	.ppexe	#C_PPU_EXIT			; ask PPU to exit
	call	PpuRelease			; free PPU mem
	mov	Bkp100, @#100			; restore vsync int
	mov	Bkp102, @#102
	mtps	#0
	mov	#MsgClr, R0			; clear screen
	emt	351
	clr	R0
	emt	350
	halt

AfterTitle:
	; allow FPS output
	inc	FpsOut

	; init some vars
	movb	#377, K17200			; use bike
	movb	#1, K11770			; fence is on
	movb	#356, K31220+2			; room with fence type
	movb	#21, K60610			; lift panel position
	clrb	K60677				; lift variable 'up' (0-up, 377-down)
	clr	RocketLaunched			; rocket back to stage

	; prepare stashes
	mov	#33., R5			; 33. records
	mov	#StashesData+4, R2
	mov	#StashesData+11, R3
20$:	mov	#5, R1				; 5 bytes each
30$:	movb	(R3)+, (R2)+
	sob	R1, 30$
	add	#9., R3
	add	#9., R2
	sob	R5, 20$

	; zero money
	MOV	#StrMoney+6, R3			; MONEY+5
	MOV	#6, R1
40$:	MOVB	#60, (R3)+
	SOB	R1, 40$

	; show panel
	call	DrawPanel

	; print strings on panel
	mov	#StrHeld, R3			; HELD/NEAR/etc..
	mov	#4, R1
	call	PrinSP
	.word	050301
	mov	#5, R1
	call	PrinSP
	.word	050325
	mov	#4, R1
	call	PrinSP
	.word	050333
	mov	#14., R1
	call	PrinSP
	.word	050146

	mov	#14.*8., Energy
	call	DrawEnergy

	MOVB	#7., K36211			; set MAND = 7.
	MOVB	#38., K36210			; set MANA = 38.
	MOV	#7.*32.+38., K36212		; set MANPS
	MOVB	#21, RoomX			; set RMAC room position = 17.
	MOV	#050205, K51142			; where to print tapes, set PTSPS
	CLR	R0
	CLRB	K24762
	clrb	TapesCount			; clear TAPCT - tapes carried total
	CLRB	K17716				; clear BIKMR
	CLRB	K36216				; clear ELECU
	CLRB	K33540				; clear DEAD
	CLRB	RoomY				; RMDN = 0 top level
	MOV	#K23030+4, K23746		; INITSTA address -> NERST
	MOV	#K46310, K36276+2		; Nina gliding addr, GLINC address -> CHARN+1
	MOV	#K40520, K25272+2		; GLIDERP address -> VECTN+1
	CLRB	K37662				; set SPEED = 0
	CLRB	K36264				; set DIR = 0
	MOV	#K70632-15., RoomAddr		; MAP-15 address -> RM+1
	INCB	R0				; R0 = 1
	movb	R0, Decen+2			; set (DECEN+1) = 1 (remove invul.)
	MOVB	R0, K33464			; set HELD value = 1 = Shuriken
	MOVB	R0, K33465			; set NEAR value = 1
	MOVB	R0, K33542			; set JUMP = 1
	MOVB	R0, K36207			; set TIME2 = 1
	movb	#C_NORMAL_ENERGY, Decen+2	; remove invulnerability

; revive/reset dead guards
GrdRevive:
	MOV	#K33543+11., R3			; TRACK1+11. (last byte of guard records)
	MOV	#12., R2			; 12. - guard record size
	MOV	#145, R1			; 101. - guards count
10$:	MOVB	(R3), R0			; <
	CMPB	R0, #5				; == 5 ?
	BNE	20$				; => NDGIT
	CLRB	(R3)
20$:	CMPB	R0, #6				; == 6 ?
	BNE	30$
	MOVB	#1, (R3)
30$:	ADD	R2, R3
	SOB	R1, 10$

	CALL	DrawHeld			; HLDOD

; INISC: Init screen, room changed
InitRoom:
	MOVB	#5, K26666			; set GDNRG = 5
	MOVB	#3, L15646			; set RMTIME = 3
	CLRB	K14640				; clear TVSWT
	MOVB	K17200, R0			; get BIKER
	INCB	R0
	BNE	10$
	CMPB	RoomY, #23			; check if RMDN == 19.
	BNE	10$
	MOV	#K17716, R3			; BIKMR
	TSTB	(R3)
	BNE	10$
	MOVB	#1, (R3)			; set BIKMR = 1
	MOV	#K17720, R3			; " BIKE ARRIVED "
	MOV	#16, R1				; 14.
	call	PrinSP				; PRINT string
	.word	050146				; screen coords
10$:	MOV	#6, R1				; 6 = number of records
	MOV	#K33466, R3			; MISL1 - Ninja object
	MOV	#7, R2				; 7 = object record size
20$:	CLRB	(R3)				; <
	ADD	R2, R3				; | next record
	SOB	R1, 20$				; repeat
	MOVB	RoomX, R1			; get RMAC room position
	MOVB	#1, R0
	DECB	R1
	BNE	K13230				; RMAC == 1 ? no => JIRRT
; DRFNT:
K13224:	MOVB	#1, R0				; !!MUT-ARG!! fence is ON?
; JIRRT:
K13230:	MOVB	R0, K70340			; set DRFNQ
	CLRB	K17635				; clear LETNO

	; clear Nina and guards buffers
	call	ClearBuffNina			; BUFCL Fill Ninja tile screen
	call	ClearBuffGuards			; BUFC2 Fill Enemy 0/1 tile screens
	; clear BuffB (background)
	mov	#BuffB, R3			; BUFFB Back tile screen address
	mov	#440, R1			; 288. words
10$:	clr	(R3)+				; <
	sob	R1, 10$				; repeat
	; fill BuffO (foreground) with 377 (nothing)
	mov	#440, R1
	mov	#177777, R5
20$:	mov	R5, (R3)+
	sob	R1, 20$
	; fill BuffD (changes) with 1 (was changed)
	mov	#BuffD, R3
	mov	#440, R1
	mov	#401, R5
30$:	mov	R5, (R3)+
	sob	R1, 30$

; make room
MakeRoom:
RoomAddr =: .+2
	MOV	#000000, R3			; room type !!MUT-ARG!!
	MOVB	RoomY, R0			; get RMDN room level
	BEQ	K13346				; top level =>
; RMDN != 0
	MOVB	(R3), R0			; get room number
; NTPRW: RMDN == 0
K13346:	BIC	#177400, R0
	ASL	R0
	MOV	K72572(R0), R3			; Get room sequence addr from the table
; NXRUT: Build the room using the room sequence
K13360:	MOVB	(R3), R0			; get marker
	INCB	R0				; 377? end of sequence?
	BNE	10$
	JMP	K24272				; => RMDUN End of room sequence
10$:	INC	R3
	PUSH	R3
	ASL	R0				; *2
	BIC	#177400, R0
	ADD	#K13426-2, R0			; + <ROUTS-2>
	JMP	@000000(R0)			; Process this marker
; BAKWD:
K13414:	POP	R3
	INC	R3
	BR	K13360				; => NXRUT
; RETRT:
K13422:	JMP	@#K13414			;!!MUT-ARG!!
; ROUTS:
K13426:	.WORD	K20120				; $00 000 - HORLN - Fill horizontally W with tile
	.WORD	K20152				; $01 001 - VERLN - Fill vertically H with tile
	.WORD	K24104				; $02 002 - BLOCK - Fill rectangle WxH with tile
	.WORD	K17762				; $03 003 - FILLB - Fill the whole room with tile
	.WORD	K20022				; $04 004 - ONECR - Fill one tile
	.WORD	K16024				; $05 005 - RKTTP - Rocket upper part
	.WORD	K20136				; $06 006 - DIAGR - Fill diagonally right-down
	.WORD	K20144				; $07 007 - DIAGL - Fill diagonally left-down
	.WORD	K20260				; $08 010 - LADSK - Ladder
	.WORD	K20346				; $09 011 - ROCKS - Supertile
	.WORD	K24004				; $0A 012 - DIBL1 - Fill triangle down-right
	.WORD	K23752				; $0B 013 - DIBL2 - Fill triangle up-right
	.WORD	K23760				; $0C 014 - DIBL3 - Fill triangle right-up
	.WORD	K23776				; $0D 015 - DIBL4 - Fill triangle right-down
	.WORD	K20240				; $0E 016 - LADTN - Wide white ladder
	.WORD	K20056				; $0F 017 - TLDTN - Joint between the ladder and the mast
	.WORD	K15226				; $10 020 - CUPB2 - Cupboard
	.WORD	K16220				; $11 021 - LFTPF - Lift platform bottom
	.WORD	K15562				; $12 022 - TREEF - Tree leaves small
	.WORD	K16400				; $13 023 - MOON  - Moon
	.WORD	K16134				; $14 024 - LFFN1 - Rocket wing left top
	.WORD	K16152				; $15 025 - RTFN1 - Rocket wing right top
	.WORD	K15634				; $16 026 - LFFN2 - Rocket wing element left bottom
	.WORD	K15670				; $17 027 - RTFN2 - Rocket wing element right bottom
	.WORD	K15724				; $18 030 - LEFEX
	.WORD	K15764				; $19 031 - RITEX
	.WORD	K17736				; $1A 032 - REDOF
	.WORD	K17754				; $1B 033 - REDON
	.WORD	K16116				; $1C 034 - LFTRE
	.WORD	K16350				; $1D 035 - RADIA
	.WORD	K20250				; $1E 036 - RADLD
	.WORD	K16324				; $1F 037 - HIDLD
	.WORD	K16100				; $20 040 - RTTRE
	.WORD	K20230				; $21 041 - GRLAD
	.WORD	K17640				; $22 042 - LETR1
	.WORD	K17646				; $23 043 - LETR2
	.WORD	K17654				; $24 044 - LETR3 - plorer
	.WORD	K16656				; $25 045 - BOX1P
	.WORD	K16742				; $26 046 - FDESK
	.WORD	K16500				; $27 047 - DOORP
	.WORD	K15376				; $28 050 - SHELP
	.WORD	K15464				; $29 051 - SHE2P
	.WORD	K15352				; $2A 052 - BARBK
	.WORD	K15332				; $2B 053 - CANIS
	.WORD	K15324				; $2C 054 - BARB2
	.WORD	K15316				; $2D 055 - BARB3
	.WORD	K15500				; $2E 056 - LEVEL - " LEVEL X " sign
	.WORD	K15264				; $2F 057 - CUPBP - Cupboard
	.WORD	K15206				; $30 060 - BARFR
	.WORD	K15200				; $31 061 - BARF2
	.WORD	K15154				; $32 062 - WNDOP
	.WORD	K15130				; $33 063 - DESKP  6x5 tiles
	.WORD	K15122				; $34 064 - DESK2
	.WORD	K15234				; $35 065 - CUPB3 - Cupboard
	.WORD	K15242				; $36 066 - CUPB4 - Cupboard
	.WORD	K15250				; $37 067 - CUPB5 - Cupboard
	.WORD	K16624				; $38 070 - BOX2P
	.WORD	K16616				; $39 071 - BOX3P
	.WORD	K15114				; $3A 072 - DESK3
	.WORD	K15106				; $3B 073 - DESK4
	.WORD	K15220				; $3C 074 - CUPB6 - Cupboard
	.WORD	K15100				; $3D 075 - DESK5
	.WORD	K15256				; $3E 076 - CUPB7 - Cupboard
	.WORD	K15472				; $3F 077 - SHE3P
	.WORD	K16576				; $40 100 - BOX4P
	.WORD	K15440				; $41 101 - DTREE
	.WORD	K15424				; $42 102 - DTRE2
	.WORD	K15432				; $43 103 - DTRE3
	.WORD	K23772				; $44 104 - LFTDI
	.WORD	K20132				; $45 105 - DIALF
	.WORD	K16770				; $46 106 - BIKRD - Motorbike
	.WORD	K17166				; $47 107 - NCGLD
	.WORD	K17024				; $48 110 - AUTOR
	.WORD	K17124				; $49 111 - BKCON
	.WORD	K17076				; $4A 112 - FRCON
	.WORD	K17152				; $4B 113 - BCON2 - Console
	.WORD	K17160				; $4C 114 - FCON2
	.WORD	K16570				; $4D 115 - BOX5P
	.WORD	K16632				; $4E 116 - BOX6P
	.WORD	K16562				; $4F 117 - BOX7P
	.WORD	K16554				; $50 120 - BOX8P
	.WORD	K16546				; $51 121 - BOX9P
	.WORD	K16540				; $52 122 - BX10P
	.WORD	K16532				; $53 123 - BX11P
	.WORD	K15072				; $54 124 - DESK6
	.WORD	K15064				; $55 125 - DESK7
	.WORD	K15056				; $56 126 - DESK8
	.WORD	K15050				; $57 127 - DESK9
	.WORD	K15042				; $58 130 - DES10
	.WORD	K15034				; $59 131 - DES11
	.WORD	K15026				; $5A 132 - DES12
	.WORD	K15020				; $5B 133 - DES13
	.WORD	K15012				; $5C 134 - DES14
	.WORD	K15004				; $5D 135 - DES15
	.WORD	K14776				; $5E 136 - DES16
	.WORD	K14770				; $5F 137 - DES17
	.WORD	K14762				; $60 140 - DES18
	.WORD	K16524				; $61 141 - BX12P
	.WORD	K14712				; $62 142 - WIND1 9x6 tiles
	.WORD	K14720				; $63 143 - WIND2 9x6 tiles
	.WORD	K14704				; $64 144 - WIND3 9x6 tiles
	.WORD	K14676				; $65 145 - WIND4 9x6 tiles
	.WORD	K14644				; $66 146 - TVCON 6x6 tiles
	.WORD	K15310				; $67 147 - BKNOB
;NOTE: MS0515 has no this			; $68 150 - WHIGD
;NOTE: MS0515 has no this			; $69 151 - YELBX


@include S217E6.MAC


K14640:	.BYTE	0				; TVSWT
K14641:	.BYTE	0				; TVCNT
K14642:	.WORD	0				; TVPPC - not used?

;NOTE: MS0515 version has no WHIGD, YELBX markers

; Room marker $66 146 - TVCON 6x6 tiles
K14644:	MOVB	#1, K14640
	MOV	#62260, R3
	MOV	#K14434, R4			; TVCNC
	MOVB	#6, K01604			; width = 6
	MOV	#6, R1				; height = 6
	BR	K14756				; Copy tiles

; Room marker $65 145 - WIND4
K14676:	MOV	#62175, R3			; BUFFB+49.
	BR	K14724				; => WINDR

; Room marker $64 144 - WIND3
K14704:	MOV	#62157, R3			; BUFFB+35.
	BR	K14724				; => WINDR

; Room marker $62 142 - WIND1
K14712:	MOV	#62164, R3			; BUFFB+40.
	BR	K14724				; => WINDR

; Room marker $63 143 - WIND2 9x6 tiles
K14720:	MOV	#62177, R3			; BUFFB+51.

; WINDR:
K14724:	CMPB	RoomY, #14			; RMDN compare to 12.
	BLO	K14740				; less than 12.
	JMP	K16466				; >= 12. => NWUKL
K14740:	MOV	#K14346, R4			; copy from
	MOVB	#11, K01604			; width = 9.
	MOV	#6, R1				; height = 6
K14756:	JMP	K16432				; Copy tiles

; Room marker $60 140 - DES18
K14762:	MOV	#62564, R3			; BUFFB+296.
	BR	K15134				; => DES2

; Room marker $5F 137
K14770:	MOV	#62602, R3			; BUFFB+310.
	BR	K15134				; => DES2

; Room marker $5E 136
K14776:	MOV	#62573, R3			; BUFFB+303.
	BR	K15134				; => DES2

; Room marker $5D 135
K15004:	MOV	#62555, R3			; BUFFB+289.
	BR	K15134				; => DES2

; Room marker $5C 134
K15012:	MOV	#62631, R3			; BUFFB+333.
	BR	K15134				; => DES2

; Room marker $5B 133
K15020:	MOV	#62616, R3			; BUFFB+322.
	BR	K15134				; => DES2

; Room marker $5A 132
K15026:	MOV	#62743, R3			; BUFFB+407.
	BR	K15134				; => DES2

; Room marker $59 131
K15034:	MOV	#62733, R3			; BUFFB+399.
	BR	K15134				; => DES2

; Room marker $58 130
K15042:	MOV	#62723, R3			; BUFFB+391.
	BR	K15134				; => DES2

; Room marker $57 127
K15050:	MOV	#62705, R3			; BUFFB+377.
	BR	K15134				; => DES2

; Room marker $56 126
K15056:	MOV	#62675, R3			; BUFFB+369.
	BR	K15134				; => DES2

; Room marker $55 125
K15064:	MOV	#62663, R3			; BUFFB+359.
	BR	K15134				; => DES2

; Room marker $54 124
K15072:	MOV	#62654, R3			; BUFFB+352.
	BR	K15134				; => DES2

; Room marker $3D 075
K15100:	MOV	#62542, R3			; UFFB+278
	BR	K15134				; => DES2

; Room marker $3B 073
K15106:	MOV	#62532, R3			; BUFFB+270.
	BR	K15134				; => DES2

; Room marker $3A 072
K15114:	MOV	#62515, R3			; BUFFB+257.
	BR	K15134				; => DES2

; Room marker $34 064
K15122:	MOV	#62640, R3			; BUFFB+340.
	BR	K15134				; => DES2

; Room marker $33 063 - DESKP 6x5 tiles
K15130:	MOV	#62625, R3			; BUFFB+329.
; DES2:
K15134:	MOV	#K14310, R4			; copy from DESKC
	MOVB	#6, K01604			; width = 6
	MOV	#5, R1				; height = 5
	BR	K15420				; => PSTLE

; Room marker $32 062 - WNDOP
K15154:	MOV	#62342, R3			; BUFFB+150.
	MOV	#K14302, R4			; WNDOC
	MOVB	#3, K01604			; width = 3
	MOV	#2, R1				; height = 2
	BR	K15420				; => PSTLE

; Room marker $31 061 - BARF2
K15200:	MOV	#64026, R3			; BUFFO+394.
	BR	K15212				; => BAR4

; Room marker $30 060 - BARFR 2x3 tiles
K15206:	MOV	#64020, R3			; BUFFO+388.
K15212:	MOV	#K13746, R4			; copy from BARFC
	BR	K15362

; Room marker $3C 074 - CUPB6 - Cupboard
K15220:	MOV	#62364, R3			; BUFFB+168.
	BR	K15270				; => CUPRP

; Room marker $10 020 - CUPB2 - Cupboard
K15226:	MOV	#62546, R3			; BUFFB+282.
	BR	K15270				; => CUPRP

; Room marker $35 065 - CUPB3 - Cupboard
K15234:	MOV	#62532, R3			;BUFFB+270.
	BR	K15270				; => CUPRP

; Room marker $36 066 - CUPB4 - Cupboard
K15242:	MOV	#62516, R3			; BUFFB+258.
	BR	K15270				; => CUPRP

; Room marker $37 067 - CUPB5 - Cupboard
K15250:	MOV	#62500, R3			; BUFFB+244.
	BR	K15270				; => CUPRP

; Room marker $3E 076 - CUPB7 - Cupboard
K15256:	MOV	#62401, R3			; BUFFB+181.
	BR	K15270				; => CUPRP

; Room marker $2F 057 - ??? 8x5 tiles
K15264:	MOV	#62517, R3			; BUFFB+259.

; CUPRP:
K15270:	MOV	#K14036, R4			; CUPBC
	MOVB	#5, K01604			; height = 5
	MOV	#10, R1				; width = 8.
	BR	K15420				; => PSTLE Copy tiles

; Room marker $67 147 - BKNOB
K15310:	MOV	#62726, R3			; BUFFB+394.
	BR	K15356				; => BAR2

; Room marker $2D 055 - BARB3
K15316:	MOV	#62732, R3			; BUFFB+398.
	BR	K15356				; => BAR2

; Room marker $2C 054 - BARB2
K15324:	MOV	#62735, R3			; BUFFB+401.
	BR	K15356				; => BAR2

; Room marker $2B 053 - CANIS 5x3 tiles
K15332:	MOV	#62740, R3			; BUFFB+404.
	MOV	#K14255, R4			; CANCR
	MOVB	#5, K01604			; width = 5
	BR	K15370				; Copy tiles, height = 3

; Room marker $2A 052 - BARBK 2x3 tiles
K15352:	MOV	#62665, R3			; BUFFB+361.
K15356:	MOV	#K14274, R4			; BARBC
K15362:	MOVB	#2, K01604			; width = 2
K15370:	MOV	#3, R1				; height = 3
	BR	K15420				; PSTLE Copy tiles

; Room marker $28 050 - SHELP 7x9 tiles
K15376:	MOV	#62471, R3			; BUFFB+237.
K15402:	MOV	#K14156, R4			; SHELC
	MOVB	#7, K01604			; width = 7
	MOV	#11, R1				; height = 9.
; PSTLE:
K15420:	JMP	K16432				; => KOONT

; Room marker $42 102 - DTRE2
K15424:	MOV	#63506, R3			; BUFFO+186.
	BR	K15444

; Room marker $43 103 - DTRE3
K15432:	MOV	#63475, R3			; BUFFO+177.
	BR	K15444

; Room marker $41 101 - DTREE 5x10 tiles
K15440:	MOV	#63461, R3			; BUFFO+165.
K15444:	MOV	#K13754, R4			; DTREC
	MOVB	#5, K01604			; width = 5
	MOV	#12, R1				; height = 10.
	BR	K15420				; Copy tiles

; Room marker $29 051 - SHE2P
K15464:	MOV	#62456, R3			; BUFFB+226.
	BR	K15402

; Room marker $3F 077
K15472:	MOV	#62503, R3			; BUFFB+247.
	BR	K15402

; Room marker $2E 056 - " LEVEL X " sign
K15500:	MOVB	RoomY, K01602			; RMDN room level
	MOV	#134, R0			; 92.
	SUB	K01602, R0
	MOVB	R0, K15550+7			; put digit in " LEVEL X " string
	MOV	#11, R1
	MOV	#K15550, R2			; " LEVEL X "
	mov	#BuffO+241., R3			; BUFFO + something
	CALL	PrintOnBgr			; BUFOM - Draw string as tiles
	DEC	(SP)
	JMP	K13422

K15550:	.ASCIZ	/@LEVEL@X@/

; Room marker $12 022 - TREEF - Tree leaves small, 5x4 tiles
K15562:	MOV	#K15610, R4			; copy from
	MOVB	#5, K01604			; width = 5
	MOV	#4, R1				; height = 4
	MOV	#63477, R3			; BUFFO+179.
	JMP	K16432				; Copy tiles

; Tree leaves small, 5x4 tiles
K15610:	.BYTE	013,014,015,015,016
	.BYTE	017,020,020,020,021
	.BYTE	017,020,020,020,025
	.BYTE	022,023,024,025,377
;
; Room marker $16 026 - LFFN2 - Rocket wing element left bottom, 2x3 tiles
K15634:	MOV	#K15662, R4			; copy from
	MOVB	#2, K01604			; width = 2
	MOV	#3, R1				; height = 3
	MOV	#62570, R3			; BUFFB+300.
	JMP	K16432				; Copy tiles

; Rocket wing element left bottom, 2x3 tiles
K15662:	.BYTE	370,370,370,321,321,000

; Room marker $17 027 - RTFN2 - Rocket wing element right bottom, 2x3 tiles
K15670:	MOV	#K15716, R4			; copy from
	MOVB	#2, K01604			; width = 2
	MOV	#3, R1				; height = 3
	; fix +1 by X
	MOV	#62601, R3			; BUFFB+309.
	JMP	K16432				; Copy tiles

; Rocket wing element right bottom, 2x3 tiles
K15716:	.BYTE	370,370,320,370,000,320

; Room marker $18 030 - LEFEX 3x3 tiles
K15724:	MOV	#K15752, R4			; copy from
	MOVB	#3, K01604			; width = 3
	MOV	#3, R1				; height = 3
	MOV	#62731, R3			; BUFFB+397.
	JMP	K16432				; Copy tiles

; Object in tiles 3x3 tiles
K15752:	.BYTE	000,000,316
	.BYTE	000,316,317
	.BYTE	316,317,317
	.EVEN
;
; Room marker $19 031 - RITEX 3x3 tiles
K15764:	MOV	#K16012, R4			; copy from
	MOVB	#3, K01604			; width = 3
	MOV	#3, R1				; height = 3
	MOV	#62737, R3			; BUFFB+403.
	JMP	K16432				; Copy tiles

; Object in tiles 3x3 tiles
K16012:	.BYTE	315,000,000
	.BYTE	317,315,000
	.BYTE	317,317,315
	.EVEN
;
; Room marker $05 005 - RKTTP - Rocket upper part 3x4 tiles
K16024:	MOV	#K70616, R4			; copy from ROKET
	MOVB	#3, K01604			; width = 3
	MOV	#4, R1				; height = 4
	MOV	#62334, R3			; BUFFB+144.
	BR	K16432				; Copy tiles

; LFTRC: Object in tiles, 5x3 tiles
K16052:	.BYTE	001,037,040,036,036
	.BYTE	041,036,036,036,036
	.BYTE	001,042,043,044,044

; RTTRC: Object in tiles, 3x2 tiles
K16071:	.BYTE	047,050,051, 036,052,053
	.EVEN

; Room marker $20 040 - RTTRE 3x2 tiles
K16100:	MOV	#K16071, R4			; copy from
	MOV	#3, R2				; width = 3
	MOV	#2, R1				; height = 2
	BR	K16234				; => SCOBD

; Room marker $1C 034 - ??? 5x3 tiles
K16116:	MOV	#K16052, R4			; copy from
	MOV	#5, R2				; width = 5
	MOV	#3, R1				; height = 3
	BR	K16234				; => SCOBD

; Room marker $14 024 - Rocket wing left top, 2x6 tiles
K16134:	MOV	#K16170, R4
	MOV	#2, R2				; width = 2
	MOV	#6, R1				; height = 6
	BR	K16234				; => SCOBD

; Room marker $15 025 - Rocket wing right top, 2x6 tiles
K16152:	MOV	#K16204, R4
	MOV	#2, R2				; width = 2
	MOV	#6, R1				; height = 6
	BR	K16234				; => SCOBD

; Rocket wing left top, 2x6 tiles
K16170:	.BYTE	000,366,366,370,370,370,370,370,370,370,321,000

; Rocket wing right top, 2x6 tiles
K16204:	.BYTE	365,000,370,365,370,370,370,370,370,370,000,320

; Room marker $11 021 - LFTPF - Lift platform bottom
K16220:	MOV	#K70602, R4			; PLATF
	MOV	#1, R1				; height = 1
	MOV	#6, R2				; width = 6
; SCOBD:
K16234:	MOV	(SP), R0
	MOVB	(R0)+, K01610			; offset low
	MOVB	(R0), K01611			; offset high
	MOV	R0, (SP)
	MOV	K01610, R3			; get offset
	ADD	#CBuffsDiffA, R3		; + base address
K16260:	PUSH	R2				; <
	PUSH	R3
K16264:	MOVB	(R4)+, (R3)+			; | <
	SOB	R2, K16264			; | repeat
	POP	R3
	ADD	#40, R3				; | + 32.
	POP	R2
	SOB	R1, K16260			; repeat
	JMP	K13422

; treasure chest
K16306:	.BYTE	026,027,030
	.BYTE	031,032,033
	.BYTE	034,035,036
	.even

; Room marker $1F 037 - ??? 2x2 tiles
; room above infinite energy room, hidden ladder
K16324:	; put some foreground tiles to hide ladder
	mov	#037, R1			; foreground tile that looks like rock wall
	movb	R1, 16.*32.+17.+BuffO
	movb	R1, 16.*32.+18.+BuffO
	movb	R1, 17.*32.+17.+BuffO
	movb	R1, 17.*32.+18.+BuffO
	br	K16466

; Room marker $1D 035 - ??? 3x3 tiles
; infinite energy room - treasure chest
K16350:	CLRB	Decen+2				; clear (DECEN+1) - infinite energy
	MOV	#K16306, R4			; copy from
	MOVB	#3, K01604			; width = 3
	MOV	#3, R1				; height = 3
	MOV	#64040, R3
	BR	K16432				; Copy tiles

; Room marker $13 023 - Moon 2x2 tiles
K16400:	MOV	#62245, R3
	cmpb	#1, BuffB+89.			; is it 'sky' tile on background?
	BNE	K16466				; => NWUKL
	MOV	#K16474, R4			; copy from
	MOVB	#2, K01604			; width = 2
	MOV	#2, R1

; Entry point: Copy tiles; K01604 = width, R1 = height, R4 = address to copy from
K16432:	MOV	#40, R2				; 32. = row width
	ADD	#CBuffsDiffA, R3		; + base address
	PUSH	R5
K16444:	MOVB	K01604, R5			; < width  !!MUT-ARG!!
	PUSH	R3
K16452:	MOVB	(R4)+, (R3)+			; | < copy tile
	SOB	R5, K16452			; | repeat
	POP	R3
	ADD	R2, R3
	SOB	R1, K16444			; repeat
	POP	R5

; NWUKL:
K16466:	DEC	(SP)
	JMP	K13422

; Moon in tiles, 2x2 tiles
K16474:	.BYTE	032,033
	.BYTE	034,035
;
; Room marker $27 047 - Door 5x8 tiles
K16500:	MOV	#K14106, R4			; copy from DOORC
	MOVB	#5, K01604			; width = 5
	MOV	#10, R1				; height = 8.
	MOV	#62540, R3
	BR	K16432				; Copy tiles

; Room marker $61 141 - ??? 11x7 tiles
K16524:	MOV	#63023, R3
	BR	K16662

; Room marker $53 123 - ??? 8x4 tiles
K16532:	MOV	#64026, R3
	BR	K16636

; Room marker $52 122 - ??? 10x7 tiles
K16540:	MOV	#63263, R3
	BR	K16602

; Room marker $51 121 - ??? 11x7 tiles
K16546:	MOV	#63655, R3
	BR	K16662

; Room marker $50 120 - ??? 10x7 tiles
K16554:	MOV	#63255, R3
	BR	K16602

; Room marker $4F 117 - ??? 11x7 tiles
K16562:	MOV	#63633, R3
	BR	K16662

; Room marker $4D 115 - ??? 11x7 tiles
K16570:	MOV	#63615, R3
	BR	K16662

; Room marker  $40 100 - ??? 10x7 tiles
K16576:	MOV	#63637, R3
K16602:	MOVB	#12, K01604			; width = 10.
	MOV	#K17527, R4			; copy from
	BR	K16674				; Copy tiles; height = 7

; Room marker $39 071 - ??? 11x7 tiles
K16616:	MOV	#63636, R3
	BR	K16662

; Room marker $38 070 - ??? 11x7 tiles
K16624:	MOV	#63617, R3
	BR	K16662

; Room marker $4E 116 - ??? 8x4 tiles
K16632:	MOV	#63765, R3
K16636:	MOVB	#10, K01604			; width = 8.
	MOV	#K16702, R4			; copy from
	MOV	#4, R1				; height = 4
	BR	K16432				; Copy tiles

; Room marker $25 045 - ??? 11x7 tiles
K16656:	MOV	#63666, R3
K16662:	MOVB	#13, K01604			; width = 11.
	MOV	#K17412, R4			; copy from
K16674:	MOV	#7, R1				; height = 7
	BR	K16432				; Copy tiles

; Box??? 8x4 tiles
K16702:	.BYTE	002,003,003,003,003,003,003,004
	.BYTE	005,006,006,006,006,006,006,007
	.BYTE	005,006,006,006,006,006,006,007
	.BYTE	010,011,011,011,011,011,011,012

; Room marker $26 046 - FDesk?? 6x4 tiles
K16742:	MOV	#K17362, R4			; copy from FDESC
	MOVB	#6, K01604			; width = 6
	MOV	#4, R1				; height = 4
	MOV	#64044, R3
K16764:	JMP	K16432				; Copy tiles

; Room marker $46 106 - BIKRD - Motorbike 11x5 tiles
K16770:	MOVB	K17200, R0			; get BIKER
	INCB	R0				; == 255. ?
	BNE	K17044
	MOV	#K17204, R4			; copy from BIKEC
	MOVB	#13, K01604			; width = 11.
	MOV	#5, R1				; height = 5
	MOV	#63730, R3
	BR	K16764

; Room marker $48 110
K17024:	MOVB	K17200, R0			; get BIKER
	CMPB	R0, #376			; 254.
	BNE	K17044
	MOVB	#20, K17200			; set BIKER = 16.
K17044:	JMP	K16466				; => NWUKL

; ??? 4x4 tiles
K17050:	.BYTE	211,212,212,213			; CONS2
	.BYTE	377,377,041,377
	.BYTE	377,377,041,377
	.BYTE	377,377,041,377

; ??? 5x1 tiles
K17070:	.BYTE	322,322,323,323,325		; CONS1
	.EVEN

; Room marker $4A 112 - FRCON 4x4 tiles
K17076:	MOV	#63760, R3			; BUFFO+356.
K17102:	MOV	#K17050, R4			; copy from
	MOVB	#4, K01604			; width = 4
	MOV	#4, R1				; height = 4
	JMP	K16432				; Copy tiles

; Room marker $49 111 - BKCON Console 5x1 tiles
K17124:	mov	#BuffO+483., R1
	MOV	#63057, R3			; BUFFB+483.
K17130: ; fill console's BuffO
	movb	#217, (R1)+
	movb	#220, (R1)+
	movb	#220, (R1)+
	movb	#220, (R1)+
	movb	#221, (R1)+
	; fill console's BuffB
	MOV	#K17070, R4			; copy from
	MOVB	#5, K01604			; width = 5
	MOV	#1, R1				; height = 1
	JMP	K16432				; Copy tiles

; Room marker $4B 113 - BCON2 Console 5x1 tiles
K17152:	mov	#BuffO+464., R1
	MOV	#63034, R3			; BUFFB+464.
	br	K17130

; Room marker $4C 114 - FCON2 4x4 tiles
K17160:	MOV	#63735, R3			; BUFFO+337
	BR	K17102				; => FCONC

; Room marker $47 107
K17166:	MOVB	#132, K37662			; set SPEED = 90.
	JMP	K16466				; => NWUKL

K17200:	.BYTE	0, 0				; BIKER
K17202:	.WORD	0				; BIKPS

; BIKEC 11x5 tiles
K17204:	.BYTE	377,377,142,143,377,377,377,377,377,377,377
	.BYTE	377,144,145,202,203,204,205,146,377,377,377
	.BYTE	147,150,151,152,206,207,155,156,157,377,377
	.BYTE	160,161,162,163,210,165,166,167,170,377,377
	.BYTE	171,172,173,174,175,176,177,200,201,377,377

; BIKMC - bike moving
K17273:	.BYTE	377,377,142,143,216,216,377,377,377,377,377
	.BYTE	377,144,145,216,216,377,377,146,216,216,377
	.BYTE	147,150,151,152,153,154,155,156,157,216,216
	.BYTE	160,161,162,163,164,165,166,167,170,216,216
	.BYTE	171,172,173,174,175,176,177,200,201,216,216

; FDESC 6x4 tiles
K17362:	.BYTE	042,043,044,044,045,046
	.BYTE	047,050,377,377,047,050
	.BYTE	047,050,377,377,047,050
	.BYTE	214,377,377,377,377,215
; BOX1C 11x7 tiles
K17412:	.BYTE	002,003,004,377,377,377,377,377,377,377,377
	.BYTE	005,006,007,377,377,377,002,003,003,004,377
	.BYTE	010,011,012,377,377,377,005,006,006,007,377
	.BYTE	002,003,003,003,004,377,010,011,011,012,377
	.BYTE	005,006,006,006,002,003,004,377,002,003,004
	.BYTE	005,006,006,006,005,006,007,377,005,006,007
	.BYTE	010,011,011,011,010,011,012,377,010,011,012
; BOX4C 10x7 tiles
K17527:	.BYTE	377,377,377,377,002,003,003,004,377,377
	.BYTE	377,377,377,377,005,006,006,007,377,377
	.BYTE	377,377,377,377,010,011,011,012,377,377
	.BYTE	377,377,002,003,003,004,377,002,003,004
	.BYTE	002,003,004,006,006,007,377,005,006,007
	.BYTE	005,006,007,006,006,007,377,005,006,007
	.BYTE	010,011,012,011,011,012,377,010,011,012

K17635:	.BYTE	000				; LETNO
	.BYTE	000,000

; Room marker $22 042 - LETR1
K17640:	MOV	#1, R0
	BR	K17660

; Room marker $23 043 - LETR2
K17646:	MOV	#2, R0
	BR	K17660

; Room marker $24 044 - LETR3
K17654:	MOV	#3, R0
K17660:	MOVB	R0, K17635			; set LETNO
	BR	K17736

;K17666:	.ASCII	/OLONEL BRIGGSY  EX/		; LETC2
;K17710:	.ASCII	/PLORER/
; no way you Briggsy, it's Satan now

K17716:	.WORD	0				; BIKMR
K17720:	.ASCII	/ BIKE ARRIVED /		; BIKAM

; Room marker $1A 032 - REDOF (do nothing, no red ninja anymore)
K17736:	dec	(SP)
	jmp	K13422				; => RETRT

; Room marker $1B 033 - REDON (do nothing, no red ninja anymore)
K17754:	br	K17736

; Room marker $03 003 - FILLB - Fill the whole room with tile
K17762:	MOV	(SP), R3
	CLR	R0
	BISB	(R3), R0			; get tile
	SWAB	R0
	BISB	(R3), R0			; get same tile again
	MOV	#BuffB, R3			; BUFFB Back tile screen address
	MOV	#110, R1			; 72. * 8. = 576.
K20004:	MOV	R0, (R3)+			; < fill 2 tiles
	MOV	R0, (R3)+			; | fill 2 tiles
	MOV	R0, (R3)+			; | fill 2 tiles
	MOV	R0, (R3)+			; | fill 2 tiles
	SOB	R1, K20004			; repeat
	JMP	K13422

; Room marker $04 004 - ONECR - Fill one tile
K20022:	POP	R3
	MOVB	(R3)+, R0
	MOVB	(R3)+, K01606
	MOVB	(R3), K01607
	PUSH	R3
	MOV	K01606, R3
	ADD	#CBuffsDiffA, R3		; + base address
	MOVB	R0, (R3)
	JMP	K13422
; Room marker $0F 017 - TLDTN
K20056:	MOV	#312, R0			; 202.
	POP	R3
	MOVB	(R3)+, K01606
	MOVB	(R3), K01607
	PUSH	R3
	MOV	K01606, R3
	ADD	#CBuffsDiffA, R3		; + base address
	MOVB	R0, (R3)+
	INCB	R0
	MOVB	R0, (R3)
	JMP	K13422

 
; Room marker $00 000 - HORLN - Fill horizontally W with tile
K20120:	MOV	#1, R2
	BR	K20156

;
K20126:	.WORD	153006,062206		; height = 6, tile = 326, offset lo, offset hi

; Room marker $45 105 - Fill diagonally right-down with tile 326, height 6
K20132:	MOV	#K20126, (SP)

; Room marker $06 006 - Fill diagonally right-down
K20136:	MOV	#41, R2				; offset = 33.
	BR	K20156				; go fill

; Room marker $07 007 - Fill diagonally left-down
K20144:	MOV	#37, R2				; offset = 31.
	BR	K20156				; go fill

; Room marker $01 001 - Fill vertically H with tile
K20152:	MOV	#40, R2				; offset = 32.
K20156:	POP	R0
	CLR	R1
	BISB	(R0)+, R1			; get height
	MOVB	(R0)+, K01604			; get tile
	MOVB	(R0)+, K01610			; get offset low
	MOVB	(R0), K01611			; get offset hi
	PUSH	R0
	MOV	K01610, R3			; offset
	ADD	#CBuffsDiffA, R3		; + base address
	MOVB	K01604, R0			; tile
K20216:	MOVB	R0, (R3)			; < put tile
	ADD	R2, R3				; | + offset
	SOB	R1, K20216			; repeat
	JMP	K13422

; Room marker $21 041 - GRLAD - Black on green ladder
K20230:	MOVB	#54, K01604			; 44.
	BR	K20266

; Room marker $0E 016 - Wide white ladder
K20240:	MOVB	#11, K01604			; 9.
	BR	K20266

; Room marker $1E 036 - Black ladder
K20250:	MOVB	#45, K01604			; 37.
	BR	K20266

; Room marker $08 010 - White ladder
K20260:	MOVB	#5, K01604			; 5.
K20266:	MOV	#37, R2				; 31.
	POP	R0
	CLR	R1
	BISB	(R0)+, R1			; get height
	MOVB	(R0)+, K01610			; get offset low
	PUSH	R0
	MOVB	(R0), K01611			; get offset hi
	MOV	K01610, R3			; offset
	ADD	#CBuffsDiffA, R3		; + base address
	MOVB	K01604, R0			; get tile
K20326:	MOVB	R0, (R3)+			; < put tile
	INCB	R0				; | next tile
	MOVB	R0, (R3)			; | put tile
	DECB	R0				; | prev tile
	ADD	R2, R3				; | + offset
	SOB	R1, K20326			; repeat
	JMP	K13422

; Room marker $09 011 - ROCKS - Supertile, 8x6 tiles
K20346:	MOV	#BuffB, R2			; BUFFB Back tile screen address
	MOV	#3, R1
10$:	MOV	#4, (PC)+
12$:	.word	4
20$:	POP	R3
	CLR	R0
	BISB	(R3)+, R0			; get Supertile number
	PUSH	R3
	PUSH	R2
	CALL	ExxPro				; EXX
	ASL	R0				; *2
	MOV	K20466(R0), R3			; get Supertile address from the table
	POP	R2
	MOV	#6, R1				; height 6
30$:	MOV	#10, R5				; <  width 8.
40$:	MOVB	(R3)+, (R2)+			;   <  copy tile number
	SOB	R5, 40$				;   repeat
	ADD	#30, R2				;   next line
	SOB	R1, 30$				; repeat
	CALL	ExxPro				; EXX
	ADD	#10, R2				; + 8.
	DEC	12$
	BNE	20$
	ADD	#240, R2
	SOB	R1, 10$				; repeat
	DEC	(SP)
	JMP	K13422

;
; Supertiles and Stashes
@include S2TILE.MAC
;

K23746:	.WORD	0				; NERST
K23750:	.BYTE	000				; TEMPN
	.EVEN

; Room marker $0B 013 - DIBL2 - Fill triangle up-right
K23752:	MOV	#177740, R3
	BR	K24010

; Room marker $0C 014 - DIBL3 - Fill triangle right-up
K23760:	MOV	#177741, R3
	BR	K24010

; LFTDT:
K23766:	.WORD	163406
	.WORD	62146				; BUFFB+26

; Room marker $44 104 - LFTDI
K23772:	MOV	#K23766, (SP)			; LFTDT

; Room marker $0D 015 - DIBL4 - Fill triangle right-down
K23776:	MOV	#41, R3				; 33.
	BR	K24010				; => DIBLK

; Room marker $0A 012 - DIBL1 - Fill triangle down-right
K24004:	MOV	#40, R3				; 32.
K24010:	MOV	R3, <K24062+2>			; set (DIBLD+1)
	POP	R0
	CLR	R2
	BISB	(R0)+, R2
	MOV	R2, R1
	MOVB	(R0)+, R5
	MOVB	(R0)+, K01610
	PUSH	R0
	MOVB	(R0), K01611
	MOV	K01610, R3
	ADD	#CBuffsDiffA, R3		; + base address
K24050:	PUSH	R2				; <
	PUSH	R3
K24054:	MOVB	R5, (R3)+
	SOB	R2, K24054			; repeat
	POP	R3
K24062:	ADD	#40, R3				;!!MUT-ARG!!
	POP	R2
	DEC	R2
	BIC	#177400, R2			; low byte
	SOB	R1, K24050			; repeat
	JMP	K13422				; => RETRT

; Room marker $02 002 - BLOCK - Fill rectangle WxH with tile
K24104:	POP	R0
	CLR	R2
	BISB	(R0)+, R2			; get width
	CLR	R1
	BISB	(R0)+, R1			; get height
	MOVB	(R0)+, R5			; get tile index
	MOVB	(R0)+, K01610			; get offset low
	PUSH	R0
	MOVB	(R0), K01611			; get offset high
	MOV	K01610, R3			; offset
	ADD	#CBuffsDiffA, R3		; + base address
K24142:	PUSH	R2				; <
	PUSH	R3
K24146:	MOVB	R5, (R3)+			; | <  put one tile
	SOB	R2, K24146			; | repeat
	POP	R3
	ADD	#40, R3				; | next row
	POP	R2
	SOB	R1, K24142			; repeat
	JMP	K13422				; => RETRT

; SPARES table, 22. records
;   +000: room level (compared to RMDN)
;   +001: room position (compared to RMAC)
;   +002: index in ROUTS table (markers)
K24170:
	.BYTE	033, 007, 106			; Motorbike
	.BYTE	000, 014, 107			; Increase glider distance
	.BYTE	033, 000, 110			; Auto run on final screen
	.BYTE	026, 030, 113			; Console
	.BYTE	026, 030, 114
	.BYTE	033, 016, 113			; Console
	.BYTE	033, 016, 114
	.BYTE	015, 016, 136
	.BYTE	033, 015, 070
	.BYTE	033, 011, 071
	.BYTE	033, 005, 053
	.BYTE	007, 033, 070
	.BYTE	022, 031, 100
	.BYTE	031, 014, 100
	.BYTE	017, 034, 070
	.BYTE	017, 005, 070
	.BYTE	017, 034, 100
	.BYTE	015, 003, 103
	.BYTE	023, 036, 101
	.BYTE	035, 037, 102
	.BYTE	026, 026, 104
	.BYTE	026, 026, 105
;
; RMDUN: End of the room sequence
K24272:	MOV	#K24352, <K13422+2>		; set return point = RETRX
	MOV	#K24170, R4			; SPARES table address
	MOV	#32, R1				; 26.
; SPART:
K24310:	CMPB	RoomY, (R4)			; <  check RMDN
	BNE	K24360				; => SPARW
	CMPB	RoomX, 1(R4)			; check RMAC
	BNE	K24360				; => SPARW
	CLR	R0
	BISB	2(R4), R0			; get byte +002
	ASL	R0
	MOV	K13426(R0), R3			; get addr from ROUTS table
	PUSH	R4
	PUSH	R1
	PUSH	R3
	JMP	(R3)
; RETRX:
K24352:	POP	R3
	POP	R1
	POP	R4
; SPARW:
K24360:	ADD	#3, R4				; next record
	SOB	R1, K24310			; repeat
	MOV	#K13414, K13422+2		; BAKWD
	CMPB	RoomY, #37			; RMDN == 31. ?
	BNE	K24436				; no => NWATR
; Room level = 31. = lower level with water
	MOV	#400, R1			; 256.
	mov	#BuffB+543., R3
	mov	#BuffO+543., R2
; WATER:
K24420:	CMPB	(R3), #307			; 199.
	BHIS	K24430				; => NTWCR
	CLRB	(R2)
; NTWCR:
K24430:	DEC	R3
	DEC	R2
	SOB	R1, K24420			; repeat => WATER
; NWATR:
K24436:	MOV	#K23030, R4			; NROBT address - Stashes
	MOV	#41, R1				; 33. records
; NROBL:
K24446:	CMPB	RoomY, (R4)			; <  == RMDN room level
	BNE	K24556				; no => NNOOS
	CMPB	RoomX, 1(R4)			; == RMAC ?
	BNE	K24556				; no => NNOOS
	MOVB	2(R4), K01610
	MOVB	3(R4), K01611
	MOV	K01610, R3
	ADD	#CBuffsDiffA, R3		; + base address
	MOVB	(R3), R0
	INCB	R0
	BNE	K24530				; => YOGRT
	MOVB	#51, (R3)			; 41. - draw left of stash box
	MOVB	#52, 1(R3)			; 42. - draw right of stash box
; YOGRT:
K24530:	SUB	#1100, R3			; <BUFFB-BUFFO>
	MOVB	#144, (R3)+			; 100. - stash background flag
	MOVB	#144, (R3)			; 100.
	MOV	R4, R3
	ADD	#4, R3
	MOV	R3, K23746			; set NERST
; NNOOS:
K24556:	ADD	#16, R4				; + 14. to next record
	SOB	R1, K24446			; repeat => NROBL

; put lift sign if we are in the room with it
LiftSigns:
	; is it a top lift room?
	MOV	RoomAddr, R3			; (RM+1)
	CMPB	(R3), #72			; room type == $3A (58.) ? lift top
	BNE	10$
	MOV	#6, R1				; 6.
	MOV	#K26660, R2			; " LIFT "
	mov	#BuffO+97., R3
	CALL	PrintOnBgr			; BUFOM - Draw string as tiles
	; is it lift bottom room?
10$:	CMPB	(R3), #74			; room type == $3C (60.) ? lift bottom
	BNE	20$
	MOV	#6, R1				; 6.
	MOV	#K26660, R2			; " LIFT "
	mov	#BuffO+108., R3
	call	PrintOnBgr			; BUFOM - Draw string as tiles
20$:	; end put lift signs

; remove rocket if we already launched it
; rocket rooms are 4 (3 with rocket and one top lid room)
RemoveRocket:
	movb	@RoomAddr, R0
	tst	RocketLaunched
	beq	90$
;	bne	02$				; already launched
;	; write SATAN on it (middle rocket part)
;	cmpb	R0, #075
;	bne	90$
;	br	90$

02$:	cmpb	R0, #013			; room 0 - top lid room
	bne	10$
	mov	#Rocket0Replace, R0
	br	ReplaceBuffB
10$:	cmpb	R0, #003			; room 1 - upper rocket part
	bne	20$
	mov	#Rocket1Replace, R0
	br	ReplaceBuffB
20$:	cmpb	R0, #075			; room 2 - middle rocket part
	bne	30$
	mov	#Rocket2Replace, R0
	br	ReplaceBuffB
30$:	cmpb	R0, #076			; room 3 - bottom rocket part
	bne	90$
	mov	#Rocket3Replace, R0
	br	ReplaceBuffB
90$:	jmp	InitRoomFin

ReplaceBuffB:
	movb	(R0)+, R1			; X
	beq	InitRoomFin
	movb	(R0)+, R2			; Y
	swab	R2
	asr	R2
	asr	R2
	asr	R2				; Y * 32.
	add	R1, R2				; index
	add 	#BuffB, R2			; R2 = addr in BuffB
	movb	(R0)+, R3			; DY
10$:	mov	R2, -(SP)
	movb	(R0), R1			; DX
20$:	movb	1(R0), (R2)+
	sob	R1, 20$
	mov	(SP)+, R2
	add	#32., R2
	sob	R3, 10$
	inc	R0
	inc	R0
	br	ReplaceBuffB

; room initialize is finished, draw it on screen
;
InitRoomFin:
	call	DrawScreen
	br	MainCycle


Rocket0Replace:
	.byte	11., 16., 01., 13., 1		; X Y DY DX tile#
	.byte	0
Rocket1Replace:
	.byte	11., 00., 18., 13., 0
	.byte	0
Rocket2Replace:
	.byte	10., 00., 18., 15., 0
	.byte	0
Rocket3Replace:
	.byte	12., 00., 12., 11., 0
	.byte	09., 05., 10., 01., 0
	; .byte	25., 05., 10., 01., 0		; it's better with right wall
	.byte	0
	.even

;
K24746:	.BYTE	041, 255			; PLAPS
K24750:	.BYTE	000				; PLADI
K24751:	.BYTE	012				; PLADS
K24752:	.BYTE	157, 157, 157, 157		; BPLAT
K24756:	.BYTE	322, 323, 323, 325		; FPLAT
K24762:	.BYTE	000, 000			; DEFGH

; //////////////////////////////////////////////////////////////////////////////
; // Main Cycle
; //////////////////////////////////////////////////////////////////////////////

; NXMAN:
MainCycle:
	call	ClearBuffNina			; BUFCL Fill Ninja tile screen

	; flamethrower tiles update (stop after use once)
	; mutable after using flamethrower
K25006:	mov	#000000, R1
	beq	K25040
K25012:	mov	#BuffG1, R3			; guard 1 by default ?
	sub	#BuffG1-BuffD, R3		; to BuffD
	mov	#1, R0				; (1) is ok
K25026:	movb	R0, (R3)
K25030:	inc	R3				; | !!MUT-CMD!! (dec or  inc)
	sob	R1, K25026
	clr	K25006+2
K25040:	; flamethrower ends

; room 158. ??? moving platform room
; remove platform
;K25120:	CMPB	(R3), #236
;	BNE	K25216
;	MOV	#K24752, R2
;	CALL	K24712				; PLATR
;	MOV	#K24751, R3
;	TSTB	K24750
;	BEQ	K25172
;	INCB	(R3)
;	INC	K24746
;	CMPB	#23, (R3)
;	BNE	K25206
;	DECB	K24750
;	BR	K25206
;K25172:	DEC	K24746
;	DECB	(R3)
;	BNE	K25206
;	INCB	K24750
;K25206:	MOV	#K24756, R2
;	CALL	K24712				; PLATR

K25216:	; fill Nina's ManBf, draw NEAR
	; (not on top rooms, we are just gliding there)
	call	PrepManBf
	tstb	RoomY				; check RMDN room level
	beq	90$				; 0 (top)
	call	K36220				; MANAR (fill MANBF)
	; if we are stepping on box?
	clr	R1
	cmpb	ManBf+46, #144			; == 100. ?
	bne	20$
	movb	@K23746, R1			; get new NEAR value
	; KIPER
20$:	mov	R1, R0				; R0 = object near
	mov	#K33465, R3			; NEAR value address
	movb	(R3), R5			; get NEAR value
	movb	R0, (R3)			; set new NEAR value
	cmpb	R0, R5				; compare old/new NEAR values
	beq	90$				; same, no need to update
	call	DrawNear			; NERDR - update NEAR indicator
90$:	call	PrepDraBuf			; (!) set to draw to buffX (!)

; VECTN:
K25272:	JMP	@#000000			;!!MUT-ARG!!

; ENDVC:
K25276:	CALL	K36266				; MANDR
	; CALL	K36220				; MANAR (again update BuffD, do we need it?)

	; skip it here - it must be set on first guard entering player's screen
	; CALL	ClearBuffGuards			; BUFC2 Fill Enemy 0/1 tile screens	

; NDRON:
K25362:	MOVB	K77520, R0			; get GLGP1
	INCB	R0
	BIC	#177774, R0
	MOVB	R0, K77520
	ASL	R0
	MOV	K77506(R0), K77516
	MOVB	K77530, R0			; get DLGP1
	INCB	R0
	CMPB	R0, #3
	BNE	10$
	CLR	R0
; GYGYU:
10$:	MOVB	R0, K77530
	ASL	R0
	MOV	K77522(R0), R3			; DLGTB
	MOV	R3, K27556+2

; // all guards cycle //

	mov	#177777, GrdAClrBuf		; for clearing their buffG1 buffG2 just once
	MOV	#K33543, R4			; guards table addr?
	MOV	#145, R1			; all guards count?

; will be jump here (!) processing for all guards in a game (!)
; (!!!) REMOVE PROCESS NOT NEEDED GUARDS
; (!!!) WE NEED ONLY WHOSE NEARBY

GProcStart:
	PUSH	R1

	; first check if that guard is 'nearby' (check by roomY +/-1 is enough)
	movb	(R4), R0			; current guard roomY
	bic	#^B1111111110000000, R0		; clean not needed attr (high byte bit - what's this?)
	movb	RoomY, R1
	sub	R1, R0
GrdSameRoom =: .+2
	mov	R0, #000000			; set current guard same room by Y flag
	add	#1, R0
	cmp	R0, #2
	blos	10$
08$:	add	#12., R4			; else skip 12. bytes for guard record
	jmp	GProcEnd			; and continue cycle
10$:	; end checking Y distance

	; check guard distance by X
	clr	R0
	bisb	2(R4), R0			; guard's roomX
	movb	RoomX, R1			; Nina's roomX
	sub	R1, R0				; distance by X
	bis	R0, GrdSameRoom			; add to same room flag
	add	#3, R0				; blaire: was 6 - way toooooooo much
	cmp	R0, #6.				; so I decreased it
	bhi	08$

	; something I dunno ...
	MOV	#7, R1
	MOVB	#6, K01604
	MOVB	13(R4), R0
	CMPB	R0, #1				; == 1 ?
	BNE	K25506
	CALL	K32176				; PANTS
K25506:	CMPB	R0, #6				; == 6. ?
	BNE	K25520
	CALL	K32176				; PANTS
K25520:	CMPB	R0, #4				; == 4 ?
	BNE	K25532
	CALL	K32176				; PANTS
K25532:	CMPB	R0, #11				; == 9. ?
	BNE	K25544
	CALL	K32176				; PANTS
K25544:	CMPB	R0, #12				; == 10. ?
	BNE	K25556
	CALL	K32176				; PANTS
K25556:	CALL	K36072				; G1DI2
	CALL	K26572				; LPRSY
	MOV	R4, R3
	ADD	#3, R3
	MOV	R3, K47720
	MOV	R3, K55316

;	; are guard in a current room?
;	MOVB	RoomY, R1			; get RMDN room level
;	MOVB	(R4), R0
;	BIC	#177600, R0
;	CMPB	R0, R1
;	BNE	GrdChkNearY
;	CMPB	RoomX, 2(R4)			; check RMAC
;	BNE	GrdChkNearY			; => NDRGA

	; do we really need that?
;	CALL	PrepManBf
;	CALL	K36112
;	CALL	PrepDraBuf
	;

; nah already filtered
; NDRGA:
;GrdChkNearY:
;	MOVB	RoomY, R1			; get RMDN room level
;	MOVB	(R4), R0
;	BIC	#177600, R0
;	SUB	R1, R0
;	ADD	#3, R0
;	CMPB	R0, #6
;	BLO	GrdChkNearX
;	JMP	K30606

;	; check guard distance by X
;	clr	R0
;	bisb	2(R4), R0			; guard's roomX
;	movb	RoomX, R1			; Nina's roomX
;	sub	R1, R0				; distance by X
;	bis	R0, GrdSameRoom			; add to same room flag
;	add	#2, R0				; blaire: was 6 - way toooooooo much
;	cmp	R0, #4.				; so I decreased it
;	blos	20$
;	jmp	K30606
;20$:	; end checking X distance

	; check if we are in a same room with guard
	tst	GrdSameRoom			; 0 - same room, else not
	bne	30$
GrdAClrBuf =: .+2
	inc	#177777				; we need to clear their both buffers just once
	bne	30$
	call	ClearBuffGuards			; clear both buffG1 buffG2 buffers
30$:	; end check same room

;	; check them dead already 11.(R4) = 5?
;	cmpb	11.(R4), #5
;	bne	48$				; still alive
;	; jump depends if it on screen (same room)
;	tst	GrdSameRoom
;	beq	46$
;	add	#12., R4
;	jmp	GProcEnd
;46$:	jmp	K30310
;48$:	; end dead men checks	

	; dunno
	cmpb	11.(R4), #2
	BLO	K25746
	JMP	K26310
K25746:	MOVB	1(R4), R1
	MOVB	4(R4), K01611
	MOVB	3(R4), K01610
	MOV	K01610, R3
	MOVB	#177777, K01607
	TSTB	(R4)
	BPL	K26060
	CALL	Random				; Get random number
	BIC	#177774, R0			; 0..3
	BEQ	K26060
	INCB	K01607
	MOVB	1(R4), R0
	ADD	#12, R0
	MOVB	R0, K01606
	MOVB	K36210, R0			; get MANA
	ADD	#12, R0
	CMPB	R0, K01606
	BHIS	K26060
	INCB	K01607
; GTRO2:
K26060:	TSTB	K36264				; check DIR
	BEQ	K26210
	CMPB	2(R4), 5(R4)
	BNE	K26160
	CMPB	6(R4), R1
	BNE	K26160
; STFFQ:
K26104:	DECB	K01607
	BEQ	K26132
	MOVB	13(R4), R0
	ASL	R0
	ADD	#7, R0

; NIKMC:
K26124:	MOVB	R0, 13(R4)
	BR	K26310				; => NWALK
; SETFF:
K26132:	CALL	Random				; Get random number
	BIC	#177770, R0			; 0..7
	ADD	#3, R0				; + 3
	MOVB	R0, K26670
	MOV	#14, R0				; 12.
	BR	K26124				; => NIKMC

; KONT1:
K26160:	DECB	R1
	DEC	R3
	CMPB	#374, R1
	BNE	K26264				; => WKOK
	MOV	#34, R1
	ADD	#40, R3
	DECB	2(R4)
	BR	K26264				; => WKOK
; GWRIT
K26210:	CMPB	2(R4), 7(R4)
	BNE	K26236
	CMPB	10(R4), R1
	BNE	K26236
	INCB	K01607
	JMP	K26104

; KONT2:
K26236:	INCB	R1
	INC	R3
	CMPB	#36, R1
	BNE	K26264				; => WKOK
	MOV	#376, R1
	SUB	#40, R3
	INCB	2(R4)
; WKOK
K26264:	MOV	R3, K01610
	MOVB	K01610, 3(R4)
	MOVB	K01611, 4(R4)
	MOVB	R1, 1(R4)
; NWALK:
K26310:	MOVB	RoomY, R1			; get RMDN room level
	MOVB	(R4), R0
	BIC	#177600, R0
	CMPB	R0, R1
	BEQ	K26332
	JMP	K30606
K26332:	CMPB	RoomX, 2(R4)			; check RMAC
	BEQ	K26346
	JMP	K30606
K26346:	;
	CALL	PrepManBf
	CALL	K36112
	CALL	PrepDraBuf
	;
	MOV	#1, R0
	TSTB	11(R4)
	BPL	K26376
	INC	R0

; LEEE9:
K26376:	MOV	#K26672, R3			; GDHIT address
	CMPB	R0, (R3)
	BNE	K26546				; => NGDHT
	MOVB	13(R4), R0
	CMPB	R0, #5
	BEQ	K26546				; => NGDHT
	CMPB	R0, #6
	BEQ	K26546				; => NGDHT
	MOV	#2, R1				; 2.
	CALL	L10244				; MONUP
	mov	#C_PPU_SOUND6, PpuComm
	MOV	#K26666, R3
	DECB	(R3)
	BEQ	K26464				; CRUSN
	CALL	Random				; Get random number
	BIC	#177774, R0
	BNE	K26546				; => NGDHT
; CRUSN:
K26464:	MOVB	#5, (R3)
	MOVB	13(R4), R0
	MOV	#6, R1
	CMPB	R0, #4				; == 4 ?
	BEQ	K26532				; => ABRSE
	CMPB	R0, #1				; == 1 ?
	BEQ	K26532				; => ABRSE
	CMPB	R0, #11				; == 9. ?
	BEQ	K26532				; => ABRSE
	CMPB	R0, #12				; == 10. ?
	BEQ	K26532				; => ABRSE
	DECB	R1

; ABRSE:
K26532:	MOVB	R1, 13(R4)
	MOV	#12, R1				; 10.
	CALL	L10244				; MONUP

; NGDHT:
K26546:	CLR	R0
	BISB	13(R4), R0
	ASL	R0
	MOV	K26626(R0), R3			; get address from NMERT table
	MOVB	K36264, R0			; get DIR
	MOVB	R0, R1
	JMP	(R3)

; LPRSY procedure
K26572:	TSTB	11(R4)
	BMI	K26602
	RETURN
K26602:	SWAB	K26670
	MOV	K26674, R3
	MOV	K26676, K26674
	MOV	R3, K26676
	RETURN

; NMERT table jump addresses
K26626:
	.WORD	K26720, K27470, K27670, K30324, K30422, K30310, K30316, K30222
	.WORD	K30236, K30260, K30274, K30406, K30014
K26660:	.ASCII	/@LIFT@/
K26666:	.BYTE	5				; GDNRG
K26667:	.BYTE	0				; GDSPD
K26670:	.WORD	000000
K26672:	.WORD	000000				; GDHIT ??
K26674:	.WORD	000000
K26676:	.WORD	000000
; BATPM
K26700:	.WORD	000012, 004012, 000012, 000010, 004010, 000011, 004011, 000011

; GDRNP:
K26720:	mov	#BuffN+101., R3
	TSTB	R0
	BEQ	K26734
	mov	#BuffN+96., R3
K26734:	MOVB	3(R4), K01606
	MOVB	4(R4), K01607
	ADD	K01606, R3
	MOVB	ManBf+23., R0
	INCB	R0
	BEQ	K27026				; => NGDPP
	MOVB	(R3), R0
	INCB	R0
	BEQ	K27026				; => NGDPP
	MOV	R3, K26674
	MOVB	#2, 13(R4)
	MOVB	#3, K26670
	CALL	Random				; Get random number
	RORB	R0
	BLO	K27026
	JMP	K27460				; => NGDKP

; NGDPP:
K27026:	MOVB	ManBf+17., R0
	INCB	R0
	BEQ	K27106
	mov	#BuffN+69., R3			; BUFFN+something
	TSTB	R1
	BEQ	K27052
	mov	#BuffN+64., R3			; BUFFN+something
K27052:	ADD	K01606, R3
	MOVB	(R3), R0
	INCB	R0
	BEQ	K27106
	MOV	R3, K26674
	MOVB	#2, K26670
	MOVB	#13, 13(R4)
	BR	K27460
K27106:	CALL	Random				; Get random number
	BIC	#177770, R0			; 0..7
	BNE	K27454
	MOVB	K33475, R0
	BNE	K27454
	MOVB	ManBf+26, R0
	INCB	R0
	BEQ	K27454

; Check relative heights (is it worth throwing dagger?)
K27136:	MOV	#K36211, R3			; MAND
	MOVB	11(R4), R0
	BIC	#177700, R0
	MOVB	(R3), R5
	SUB	R5, R0
	ADD	#4, R0
	CMPB	R0, #11
	BHIS	K27454
	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3
	ADD	#144, R3
	MOVB	#004, K01605
	MOVB	#10, K01604
	CLRB	K01607
	MOVB	1(R4), R0
	ADD	#12, R0
	MOVB	R0, K01606
	MOVB	K36210, R0			; get MANA
	ADD	#12, R0
	CMPB	R0, K01606
	BHIS	K27316
	MOVB	#1, K01605
	MOVB	#4, K01604
	MOVB	#1, K01607
	DEC	R3
	DEC	R3
	DEC	R3

; GTROK:
K27316:
;	MOVB	K36264, R0			; get DIR
;	CMPB	R0, K01607
	cmpb	K36264, K01607
;
	BNE	K27454
	MOVB	1(R4), R0
	MOVB	K01605, K36202
	ADD	K36202, R0
	MOVB	R0, K33477
	MOV	R3, K01610
	MOVB	K01610, K33500
	MOVB	K01611, K33501
	MOVB	K01604, R0
	MOVB	R0, K33502
	MOVB	R0, K33503
	MOVB	#324, K33475
	MOVB	11(R4), R0
	BIC	#177700, R0
	ADD	#3, R0
	MOVB	R0, K33476
	MOVB	#2, 13(R4)
	MOVB	#1, K26670
	BR	K27460

; NGTRO:
K27454:	CALL	K27566				; TURNQ
K27460:	MOV	K77516, R3
	JMP	K30450				; => ENDGP

K27470:	mov	#BuffN+38., R3			; BUFFN+something
	TSTB	R1
	BEQ	K27504
	mov	#BuffN+33., R3			; BUFFN+something
K27504:	MOVB	ManBf+15., R0
	INCB	R0
	BEQ	K27552
	MOVB	3(R4), K01606
	MOVB	4(R4), K01607
	ADD	K01606, R3
	MOVB	(R3), R0
	INCB	R0
	BEQ	K27552
	MOVB	#4, 13(R4)
	BR	K27556
K27552:	CALL	K27566				; TURNQ
K27556:	MOV	#000000, R3
	JMP	K30450				; => ENDGP

; TURNQ procedure
K27566:	CALL	Random				; Get random number
	BIC	#177774, R0			; 0..3
	BEQ	10$
	RETURN
10$:	MOVB	K36210, R0			; get MANA
	ADD	#4, R0
	MOVB	1(R4), R5
	SUB	R5, R0
	MOV	#1, R1
	SUB	#4, R0
	TSTB	R0
	BMI	20$
	DECB	R1
; TRNLF:
20$:	MOVB	K36264, R0			; get DIR
	CMPB	R0, R1
	BNE	30$
	RETURN
30$:	MOVB	13(R4), R0
	ASL	R0
	ADD	#7, R0
	MOVB	R0, 13(R4)
	RETURN

; GDPNP:
K27670:	MOV	#K26670, R3
	CMPB	#2, (R3)
	BNE	K27734
	PUSH	R3
	MOV	K26674, R3
	MOVB	(R3), R0
	INCB	R0
	BEQ	K27732
	mov	#C_PPU_SOUND2, PpuComm
	MOVB	#14, R1
	CALL	Decen				; DECEN
; NUN52:
K27732:	POP	R3
; NUN1:
K27734:	DECB	(R3)
	BNE	K27744
	CLRB	13(R4)
; LEEEE:
K27744:	MOV	#K76606, R3			; GDPNC
	JMP	K30450				; => ENDGP

; FFIRE:
K27754:	.BYTE	243, 244
	.BYTE	244, 244
	.BYTE	244, 244
	.BYTE	244, 244
	.BYTE	244, 245

; GDFFP:
K30014:	mov	#BuffG1+102., R2		; BUFG1+102.
	MOV	#105205, R5			; incb R5 - command
	MOV	#005203, R0			; inc R3 - command
	CMPB	K36264, #1			; DIR == 1 ?
	BNE	K30054
	mov	#BuffG1+95., R2			; BUFG1+95.
	MOV	#105305, R5			; decb R5 - command
	MOV	#005303, R0			; dec R3 - command
K30054:	MOV	R0, K30170			; set FLDID command
	MOV	R0, K25030
	MOV	R5, K30174
	MOVB	1(R4), R5
	DECB	R5
	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3
	ADD	R2, R3
	MOV	R3, K25012+2			; FLDIR
	MOV	#K27754, R2
	MOV	#12, R1
	MOV	R1, K25006+2
K30140:	CMPB	R5, #31
	BHIS	K30170				; => FLDID
	MOVB	174500(R3), R0
	CMPB	R0, #307			; 199.
	BHIS	K30200
	MOVB	(R2), (R3)
	MOVB	#1, 173400(R3)

; FLDID:
K30170:	INC	R3				;WARN
	INC	R2
K30174:	INCB	R5
	SOB	R1, K30140			; repeat
K30200:	DECB	K26670
	BNE	K30214
	MOVB	#7, 13(R4)
K30214:	MOV	#K76606, R3			; GDPNC
	BR	K30450

K30222:	MOVB	#10, 13(R4)
	MOV	#K77261, R3
	BR	K30450

K30236:	CLRB	13(R4)
	MOV	#K77261, R3
K30246:	MOV	#1, R0
	XOR	R0, K36264			; DIR
	BR	K30450

; DTRN1:
K30260:	MOVB	#12, 13(R4)
	MOV	#K77037, R3
	BR	K30450				; => ENDGP

; DTRN2:
K30274:	MOVB	#1, 13(R4)
	MOV	#K77037, R3
	BR	K30246				; => ANRKE

; DEDGP:
K30310:	MOV	#K77403, R3			; GDEDC - dead guard titles
	BR	K30450

; dead cat
K30316:	MOV	#K77455, R3
	BR	K30450

; GDKCP:
K30324:	MOV	#K26670, R3
	CMPB	#1, (R3)
	BNE	K30370
	PUSH	R3
	MOV	K26674, R3
	MOVB	(R3), R0
	INCB	R0
	BEQ	K30366
	mov	#C_PPU_SOUND1, PpuComm
	MOV	#7, R1
	CALL	Decen				; DECEN

; NUN25:
K30366:	POP	R3
K30370:	DECB	(R3)
	BNE	K30400
	CLRB	13(R4)
K30400:	MOV	#K77333, R3			; GKIKC
	BR	K30450

; GDLLP:
K30406:	MOVB	#3, 13(R4)
	MOV	#K76657, R3			; GDLLC
	BR	K30450

K30422:	mov	#C_PPU_SOUND0, PpuComm
	MOVB	#6, R1				; 6.
	CALL	Decen				; DECEN
	MOVB	#1, 13(R4)
	MOV	#K76757, R3			; DOGL2

; ENDGP:
K30450:	MOV	R3, K30534+2
	MOV	#Guard1Dir, R3
	TSTB	11(R4)
	BPL	K30470
	INC	R3
K30470:	MOVB	K36264, (R3)			; copy DIR
	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3
	MOV	#BuffG1, R2			; Enemy 0 tile screen address
	TSTB	11(R4)
	BPL	K30532
	MOV	#BuffG2, R2			; Enemy 1 tile screen address
K30532:	ADD	R2, R3
K30534:	MOV	#000000, R2
K30540:	MOV	#7, R1
	MOVB	K30604, K01604		
	MOVB	11(R4), R0
	BIC	#177600, R0
	MOVB	R0, K01607
	MOVB	1(R4), R0
	CALL	DrawObject			; Guard DRWOB (BuffG1 2?)
; ??? TODO WHAT IS THIS ???
;	CALL	K36112				; GRDAR
	BR	K30756				; => NDRGB

K30604:	.WORD	6				; ??

; NOTOS:
K30606:	MOVB	13(R4), R0
	CMPB	R0, #14				; == 12. ?
	BNE	K30630
	MOVB	#7, 13(R4)
	BR	K30756
K30630:	CMPB	R0, #13
	BEQ	K30752
	CMPB	R0, #11
	BNE	K30664
	MOV	#1, R0
	XOR	R0, K36264			; DIR
	MOVB	#1, 13(R4)
	BR	K30756
K30664:	CMPB	R0, #7
	BNE	K30704
	MOV	#1, R0
	XOR	R0, K36264			; DIR
	BR	K30752
K30704:	CMPB	R0, #6
	BEQ	K30756
	CMPB	R0, #4
	BNE	K30730
K30720:	MOVB	#1, 13(R4)
	BR	K30756

; LEEE7:
K30730:	CMPB	R0, #5
	BEQ	K30756
	CMPB	R0, #12
	BEQ	K30720
	CMPB	R0, #2
	BLO	K30756
; FINGR:
K30752:	CLRB	13(R4)
K30756:	MOV	#K36212, R3			; MANPS address
	MOV	R3, K47720
	MOV	R3, K55316
	CALL	K36072				; G1DI2
	CALL	K26572				; LPRSY
	ADD	#12., R4
	MOV	#ManBf+5, R3
	MOV	R3, K55312
	MOVB	#005, R0
	MOVB	R0, K55334
	INCB	R0
	MOVB	R0, K30604
	MOVB	R0, K36200
	INCB	R0
	MOVB	R0, K30540+2
	INCB	R0
	MOVB	R0, K36142+2
	MOVB	#14, R0
	MOVB	R0, K55452
	MOVB	R0, K55436
	MOVB	#32, R0
	MOVB	R0, K55446
	MOVB	R0, K55432

GProcEnd:
	POP	R1
	DEC	R1
	BEQ	10$
	JMP	GProcStart			; => NXGRD

10$:	CLRB	K26672				; clear GDHIT

	; treasure chest flashing attrs (removed)

; animate fence electric sparks
K31212:	MOV	RoomAddr, R3			; get (RM+1)
	MOVB	(R3), R0			; get room type
K31222 =: .+2
K31220:	CMPB	R0, #356			; room with fence?
	BNE	K31324
	mov	#BuffB+135., R3
	mov	#BuffD+135., R2
	MOVB	#12, R1				; 10.	
10$:	CALL	Random				; Get random number
	BIC	#177774, R0
	ADD	#117, R0
	MOVB	R0, (R3)+
	INC	R3
	MOVB	#1, R0
	MOVB	R0, (R2)+
	INC	R2
	MOVB	R0, (R2)
	CALL	Random				; Get random number
	BIC	#177774, R0
	ADD	#122, R0
	MOVB	R0, (R3)
	ADD	#36, R3
	ADD	#36, R2
	SOB	R1, 10$				; repeat

; NFNCE:
K31324:	MOVB	L15646, R0			; get RMTIME
	BEQ	K31344
	DECB	R0
	MOVB	R0, L15646			; set RMTIME
	JMP	K31712				; => MISGO

; NJSTN:
K31344:	CMPB	RoomY, #37			; RMDN == 31. $1F ?
	BNE	K31360
	JMP	K31712				; => MISGO

; Room level != 31.
; test room types with bats
K31360:	MOV	RoomAddr, R3			; get (RM+1)
	MOVB	(R3), R0			; get room type
	CMPB	R0, #35				; 29. $1D
	BEQ	K31430
	CMPB	R0, #43				; 35. $23
	BEQ	K31430
	CMPB	R0, #42				; 34. $22
	BEQ	K31430
	CMPB	R0, #46				; 38. $26
	BEQ	K31430
	CMPB	R0, #52				; 42. $2A
	BEQ	K31430
	JMP	K31712				; => MISGO

; BATSI:
K31430:	call	Random				; RND
	BIC	#177700, R0			; 0..63.
	INCB	R0
	CMPB	R0, #5				; 5.
	BHIS	K31626
	MOV	#K33475, R3
K31454:	ADD	#7, R3
	DECB	R0
	BNE	K31454
	MOVB	(R3), R0
	BNE	K31626
	MOVB	#340, (R3)+
	MOVB	#11, (R3)+
	CLRB	(R3)+
	MOVB	#40, (R3)+
	MOVB	#1, (R3)+
	call	Random				; RND
	BIC	#177770, R0
	ASL	R0
	MOV	#K26700, R4
	ADD	R0, R4
	MOVB	(R4), (R3)+
	MOVB	1(R4), (R3)
	call	Random				; RND
	BIC	#177776, R0
	BEQ	K31626
	MOV	#14, R0
	MOVB	(R3), R5
	XOR	R0, R5
	MOVB	R5, (R3)
	MOVB	-(R3), R5
	XOR	R0, R5
	MOVB	R5, (R3)
	MOVB	-(R3), K01607
	MOVB	-(R3), K01606
	MOVB	#37, -(R3)
	INC	R3
	ADD	#37, K01606
	MOVB	K01606, (R3)+
	MOVB	K01607, (R3)

; NBATI:
K31626:	MOV	#4, R1				; 4.
	MOV	#K33504, R4
	MOV	#7, R2
K31642:	MOVB	1(R4), R0			; <
	CMPB	R0, #10
	BEQ	K31662
	CMPB	R0, #12
	BNE	K31706
K31662:	MOVB	5(R4), K01602			; room number
	MOV	#3, R0
	XOR	R0, K01602
	MOVB	K01602, 5(R4)
K31706:	ADD	R2, R4
	SOB	R1, K31642			; repeat

; MISGO:
K31712:	MOV	#6, R0
	MOV	#K33466, R4			; MISL1 - Ninja object

K31722:	MOVB	R0, K32300			; set MSLNO
	MOVB	(R4), R0
	BNE	K31736
	JMP	K32436

; draw bats (missiles?)
K31736:	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3
	ADD	#BuffD, R3			; BUFFD
	movb	#2, (R3)			; update it with (2)
	MOVB	5(R4), R5
	PUSH	R1
	MOV	#2, R1

; MIKY2
K32000:	BIT	#1, R5				; bit 0 ?
	BEQ	K32012
	CALL	K33274				; UPOBJ - Object moves up
K32012:	BIT	#2, R5				; bit 1 ?
	BEQ	K32024
	CALL	K33362				; DOWNO - Object moves down
K32024:	BIT	#4, R5				; bit 2 ?
	BEQ	K32036
	CALL	K33404				; LEFTO - Object moves left
K32036:	BIT	#10, R5				; bit 3 ?
	BEQ	K32050
	CALL	K33424				; RITEO - Object moves right
K32050:	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3			; R3 = object offset
	ADD	#BuffB, R3			; BUFFB Back tile screen address
	CMPB	(R3), #307
	BLO	K32112

; NOEL3:
K32102:	CLRB	(R4)
	POP	R1
	JMP	K32436
K32112:	ADD	#3300, R3			; + <BUFG1-BUFFB>
	CMPB	K32300, #6			; MSLNO == 6. ?
	BNE	K32146
	MOVB	(R3), R0
	INCB	R0
	BEQ	K32146
	MOV	#1, R0
K32140:	MOVB	R0, K26672			; set GDHIT
	BR	K32102

; NOEL2:
K32146:	ADD	#1100, R3			; + <BUFG2-BUFG1>
	CMPB	K32300, #6			; MSLNO == 6. ?
	BNE	K32302
	MOVB	(R3), R0
	INCB	R0
	BEQ	K32302
	MOV	#2, R0
	BR	K32140

; PANTS procedure: ??
K32176:	MOV	#7, R0				; 7.
	MOV	#ManBf+6, K55312		; <MANBF+6> address -> PUM06+1
	MOVB	R0, K55334
	INCB	R0
	MOVB	R0, K30604
	MOVB	R0, K36200
	MOV	#3, R0
	MOVB	R0, K30540+2
	INCB	R0
	MOVB	R0, K36142+2
	MOV	#20, R0
	MOVB	R0, K55452
	MOVB	R0, K55436
	MOV	#30, R0
	MOVB	R0, K55446
	MOVB	R0, K55432
	CLR	R0
	RETURN

K32300:	.WORD	0				; MSLNO

K32302:	SUB	#2200, R3
	CMPB	K32300, #6			; MSLNO == 6. ?
	BEQ	10$
	CMPB	(R3), #340
	BHIS	10$
	mov	#C_PPU_SOUND5, PpuComm
	MOV	#5, R1
	CALL	Decen				; DECEN
	CMPB	(R4), #340
	BLO	K32102
	BR	K32364
10$:	MOVB	6(R4), R5
	DECB	R1
	BEQ	K32364
	JMP	K32000

K32364:	POP	R1
	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	MOV	K01610, R3
	ADD	#BuffN, R3			; BUFFN Ninja tile screen address
	MOVB	(R4), (R3)
	RORB	(R4)
	BHIS	K32422
	.WORD	005727				; TST #000261 or XOR 1
K32422:	SEC
	ROLB	(R4)
	SUB	#3300, R3
	MOVB	#1, (R3)

; NDOMS:
K32436:	ADD	#7, R4
	MOVB	K32300, R0			; get MSLNO
	DECB	R0
	BEQ	K32456
	JMP	K31722
K32456:	TSTB	RoomY				; check RMDN room level
	BNE	K32542				; not 0 (top) =>

; we're on the top room level
	MOVB	K36210, R2			; get MANA
	ADD	#60, R2
	ADD	#156, R2
	MOV	R2, K40276			; set GLIPS
	MOVB	#5, K40300			; set GLIDN = 5
	MOV	#K40301, R2			; GLIDC
	MOV	#BuffO, R1			; BUFFO Front tile screen address
	CALL	K40356				; DRGLI
;	MOV	#K46162, R2			; NINDC
;	MOV	#BuffD, R1			; BUFFD
;	CALL	K40356				; DRGLI

; TV processing
; PICRT:
K32542:	TSTB	K14640				; do we have TV in the room?
	BEQ	SetTermColor
	MOV	#K14641, R4			; TVCNT
	DECB	(R4)
	BNE	K32612
	call	Random				; RND2
	MOVB	R0, (R4)
	BIC	#177774, R0
	BNE	K32624
	call	Random				; RND2
	BIC	#177774, R0
	ADD	#4, R0
	BR	K32650
K32612:	MOVB	1(R4), R0
	BIT	#4, R0				; bit 2 ?
	BNE	K32650
K32624:	call	Random				; RND2
	BIC	#177774, R0
	CMPB	R0, 1(R4)
	BNE	K32650
	INCB	R0
	BIC	#177774, R0			; 0..3
K32650:	MOVB	R0, 1(R4)
	ASL	R0
	ASL	R0				; *4
	MOV	R0, R1
	ASL	R0				; *8.
	ADD	R1, R0				; *12.
	MOV	R0, R2
	ADD	#K14500, R2			; + TVFZ1

	; change TV screen tiles, set buffD to update them
	mov	#BuffB+133., R3			; TV positions in buffers
	mov	#BuffD+133., R4
	mov	#3, R5				; TV height
10$:	mov	#4, R1				; TV width
20$:	movb	(R2)+, (R3)+
	movb	#1, (R4)+
	sob	R1, 20$
	add	#34, R4
	add	#34, R3
	sob	R5, 10$

; coloring terminals
; TODO: nah, make it better?
SetTermColor:
	mov	K36212, R3			; get MANPS
	add	#BuffO+98., R3
	movb	#^B01000, R0			; blue background
	cmpb	(R3), #212			; is we at terminal
	bne	20$
	mov	#^B11000, R0			; red background
	; set BuffD with terminal as 'was changed'
	; terminals are fixed at X=17., Y=10. (4 tiles) (lift and fence)
	; rocket launch terminal is at X=4., Y=11. 
	mov	#2, R1
	mov	#10.*32.+17.+BuffD, R2
	cmpb	@RoomAddr, #075			; are we in the rocket launch room?
	bne	10$
	mov	#11.*32.+4.+BuffD, R2
10$:	movb	R1, (R2)+
	movb	R1, (R2)+
	movb	R1, (R2)+
	movb	R1, (R2)+
20$:	; set color attrs for terminal tiles
	mov	R0, K46013
	mov	R0, K46034
	mov	R0, K46055

; OK, draw screen then
;
DoPic1:

; //////////////////////////////////////////////////////////////////////////////
; // MainCycle ends 
; //////////////////////////////////////////////////////////////////////////////

	; wait some if we are too fast
	; at last, I'm putting wait in a game ^)
	cmp	VsyGme, #4
	blo	.-6
	clr	VsyGme

	CALL	DrawScreen			; DOPIC - Show the room on the screen

	TSTB	K36216				; check ELECU
	BEQ	K33052

; electrocuted?
; NICK2: Set Ninja to random color, but not blue or green
; not implemented
K33012:	CALL	Random				; Get random number
	BIC	#177770, R0			; 0..7
	CMPB	R0, #1				; == 1 blue ?
	BEQ	K33012				; yes => again
	CMPB	R0, #4				; == 4 green ?
	BEQ	K33012				; yes => again
	MOV	#000024, R1			; 20.
	CALL	Decen				; DECEN
; NICK:
K33052:	TSTB	K33540				; check DEAD
K33056:	BEQ	K33114				; alive =>
	; Dead
	TSTB	K33542				; check JUMP
	BNE	K33114
	MOV	#K47606, R2			; fall down tiles
	MOVB	#1, K33542			; set JUMP = 1
	MOV	#K54302, R3			; LEP5P address
	MOV	R2, K36276+2
	MOV	R3, K25272+2			; set JMP address
K33114:
;	CMPB	K33540, #2			; DEAD == 2 ?
;	BEQ	K33270

K33124:
	; DEBUG
	; 1) 6500 1400
	; output timer vals

	jmp	MainCycle


; UPOBJ procedure - Object moves up
K33274:	TSTB	1(R4)				; Y == 0 ?
	BEQ	K33350				; => OBGON
	DECB	1(R4)				; Y--
	MOV	#177740, R2			; -32.

; => MOVOJ
K33312:	MOVB	3(R4), K01610
	MOVB	4(R4), K01611
	ADD	R2, K01610
	MOVB	K01610, 3(R4)
	MOVB	K01611, 4(R4)
	RETURN

; OBGON:
K33350:	CLRB	(R4)
	TST	(SP)+
	TST	(SP)+
	JMP	K32436				; => NDOMS

; DOWNO procedure - Object moves down
K33362:	CMPB	#21, 1(R4)			; Y == 17. ?
	BEQ	K33350				; => OBGON
	INCB	1(R4)				; Y++
	MOV	#40, R2				; 32.
	BR	K33312				; => MOVOJ

; LEFTO procedure - Object moves left
K33404:	TSTB	2(R4)				; X == 0 ?
	BEQ	K33350				; => OBGON
	DECB	2(R4)				; X--
	MOV	#177777, R2			; -1
	BR	K33312				; => MOVOJ

; RITEO procedure - Object moves right
K33424:	CMPB	#37, 2(R4)			; X == 31. ?
	BEQ	K33350				; => OBGON
	INCB	2(R4)				; X++
	MOV	#1, R2				; 1
	BR	K33312				; => MOVOJ


K33464:	.BYTE	1				; HELD value
K33465:	.BYTE	0				; NEAR value
; Objects table, 7 bytes each
;   +001: X
;   +002: Y
;   +003 +004: Object offset in the room buffers
; MISL1 - Ninja object
K33466:	.BYTE	0
K33467:	.BYTE	0
K33470:	.BYTE	0
K33471:	.BYTE	0
K33472:	.BYTE	0
K33473:	.BYTE	0
K33474:	.BYTE	0
; MISL2 - Guard object
K33475:	.BYTE	0
K33476:	.BYTE	010
K33477:	.BYTE	031
K33500:	.BYTE	031
K33501:	.BYTE	001
K33502:	.BYTE	0
K33503:	.BYTE	0
; MISL3 - 4 objects - bats
K33504:	.BYTE	000, 010, 027, 027, 001, 000, 000
	.BYTE	000, 010, 027, 027, 001, 000, 000
	.BYTE	000, 010, 027, 027, 001, 000, 000
	.BYTE	000, 010, 027, 027, 001, 000, 000
;
K33540:	.BYTE	0				; DEAD: 0=alive, 1=enery out, 2=time out
	.EVEN

K33542:	.BYTE	0				; JUMP

; ???
@include S23763.MAC
;
Guard1Dir:	.byte	0			; guard 1 DIR
Guard2Dir:	.byte	0			; guard 2 DIR
K36041:		.byte	0			; ??? in drawing it's Nina DIR

; G1DI2 procedure: ??
K36072:	MOVB	12(R4), R0
	MOVB	K36264, 12(R4)			; copy DIR
K36104:	MOVB	R0, K36264			; set DIR
	RETURN

; GRDAR procedure: ??
K36112:	MOVB	4(R4), K01611
	MOVB	3(R4), K01610
	MOV	K01610, R3
	ADD	#BuffD, R3			; BUFFD address
	MOV	#K46162, R2			; NINDC address
K36142:	MOV	#10, R1
	movb	K36200, K01604
	MOVB	11(R4), K01607
	BICB	#177600, K01607
	MOVB	1(R4), R0
	JMP	DrawObject			; Guard DRWOB (ManBf)


K36200:	.WORD	000006
K36202:	.WORD	000000

K36204:	.ASCII	/888/				; TIME1 - timer current value, 3-char
K36207:	.BYTE	10.				; TIME2 - timer counter
K36210:	.BYTE	10.				; MANA ??
K36211:	.BYTE	10.				; MAND ??
K36212:	.BYTE	112				; MANPS ??
K36213:	.BYTE	001
RoomY:	.byte	0				; RMDN - room level, 0=top, 31.=water
RoomX:	.byte	0				; RMAC - room position 0=left, 31.=right
K36216:	.BYTE	0				; ELECU ??
	.EVEN

; MANAR procedure: ??
; put Nina on buffers
K36220:	MOV	K36212, R3			; get MANPS
	ADD	#BuffD, R3			; + BUFFD
	MOV	#K46162, R2			; get NINDC
	MOV	#8., R1				; DY 8. by default
K36240:	MOVB	#6., K01604			; DX 6. by default
	MOVB	K36211, K01607			; get MAND
	MOVB	K36210, R0			; get MANA
	JMP	DrawObject			; Nina DRWOB (ManBf)

K36264:	.WORD	0				; DIR - mirroring flag

; MANDR procedure: ??
K36266:	MOV	K36212, R3			; get MANPS
	ADD	#BuffN, R3			; + BUFFN: Ninja tile screen address
K36276:	MOV	#000000, R2			;!!MUT-ARG!!
	MOV	#7, R1				; 7.
	BR	K36240

; MOVAC procedure: ??
K36310:	MOVB	K36264, R2			; get DIR
	ASL	R2
	BIC	#177400, R2
	DEC	R2
	MOVB	K36210, R0			; get MANA
	ADD	R2, R0
	MOVB	R0, K36210			; set MANA
	ADD	R2, K36212			; MANPS
	RETURN

; EDGES procedure
K36344:	MOVB	K36210, R0			; get MANA
	TSTB	K36264				; check DIR
	BEQ	K36374				; left =>
; DIR != 0: right
	CMPB	R0, #35				; MANA == 29. ?
	BEQ	K36366	;TODO
	RETURN

K36366:	POP	R3
	JMP	K37746				; => RITSC - go one room right
; DIR = 0: left
K36374:	CMPB	R0, #375			; == 253. ?
	BEQ	K36404	;TODO
	RETURN

K36404:	POP	R3
	JMP	K40012				; => LEFSC - go one room left

; JMP1P: ??? - Vector for (VECTN+1)
K36412:	CALL	K40726				; OFTOP
	CALL	K36344				; EDGES
	CALL	K37270				; HITJJ
	CALL	K36310				; MOVAC
	MOV	#4, R1
	MOV	#ManBf+1, R3
K36442:	MOVB	(R3)+, R0
	INCB	R0
	CMPB	R0, #310
	BHIS	K36504				; => HRISL
	SOB	R1, K36442			; repeat
	DECB	K36211
	SUB	#40, K36212			; MANPS
	MOV	#K37662, R3
	DECB	(R3)
	BEQ	K36504				; => HRISL
	JMP	K25276				; => ENDVC

; HRISL:
K36504:	MOVB	#004, R0			; 4.
; ARSED:
K36510:	MOVB	R0, K37662			; set SPEED
	MOV	#K36546, R3			; SOMER -> (VECTN+1)
	MOV	#K46352, R2			; SOM1C -> (CHARN+1)
	CLRB	K36534				; clear SOMPS
	JMP	K55246				; => SETVC - set vectors

K36534:	.BYTE	0				; SOMPS
	.EVEN

; SOMAN:	SOM1C, SOM2C, SOM3C, SOM4C
K36536:	.WORD	K46352, K46413, K46455, K46517

; SOMER: ??? - Vector for (VECTN+1)
K36546:	MOVB	K36534, R3			; get SOMPS
	INCB	R3
	BIC	#177774, R3			; 0..3
	MOVB	R3, K36534			; set SOMPS
	ASL	R3				; *2
	MOV	K36536(R3), K36276+2
	BR	K36646				; => JMP2P

; FKIKS: ??? - Vector for (VECTN+1)
K36576:	MOV	#K36612, R3			; FKIKP -> (VECTN+1)
	MOV	#K47462, R2			; FKIKC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; FKIKP: ??? - Vector for (VECTN+1)
K36612:	MOVB	ManBf+6, R0
	INCB	R0
	BEQ	K36646
	mov	#BuffG1+32., R2
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BNE	10$
	mov	#BuffG1+37., R2
10$:	CALL	K51646				; HITGQ

; JMP2P:
K36646:	CALL	K36344				; EDGES
	CALL	K37270				; HITJJ
	CALL	K36310				; MOVAC
	DECB	K37662				; decrement SPEED
	BEQ	K36674
	JMP	K25276				; => ENDVC
K36674:	MOVB	#6, K37662			; set SPEED = 6
	MOV	#K36712, R3			; JMP3P
	JMP	K55252				; SETV2 - set vector

; JMP3P:
K36712:	CALL	K54212				; OFBOT
	CALL	K36344				; EDGES
	CALL	K37270				; HITJJ
	MOVB	ManBf+42., R0
	INCB	R0
	CMPB	R0, #310
	BLO	K36746
	JMP	K55262
K36746:	CALL	K50274				; FLORQ
	BEQ	K36760
	JMP	K50744
K36760:	CALL	K36310				; MOVAC
	INCB	K36211				; increment MAND
	ADD	#40, K36212			; + 32. MANPS
	MOV	#K47336, K36276+2
	DECB	K37662				; decrement SPEED
	BEQ	K37016
	JMP	K25276

K37016:	MOVB	#31, R0				; 25.
K37022:	MOVB	R0, K37662			; set SPEED = 25.
	MOVB	#1, R0
	MOVB	R0, K54510+2			; set (HIGHT+1)
	MOVB	R0, K33542			; set JUMP
	MOV	#K47606, R2			; TTFAL -> (CHARN+1)
	MOV	#K37060, R3			; JMP4P -> (VECTN+1)
	JMP	K55246				; => SETVC - set vectors

K37056:	.WORD	0				; TTFAL

; JMP4P: - Vector for (VECTN+1)
K37060:	CALL	K54212				; OFBOT
	CALL	K36344				; EDGES
	CALL	K50274				; FLORQ
	BEQ	K37102
	JMP	K54510				; => HIGHT
K37102:	MOV	#K54510+2, R3			; HIGHT+1 addr
	INCB	(R3)
	RORB	K37056				; TTFAL
	BHIS	K37120
	.WORD	005727				; TST #000261 or XOR 1
K37120:	SEC
	ROLB	K37056				; TTFAL
	BNE	K37134
	JMP	K37164				; => NACRF
K37134:	CALL	K37270				; HITJJ
	MOVB	ManBf+52, R0
	INCB	R0
	CMPB	R0, #310
	BLO	K37160
	JMP	K55262
K37160:	CALL	K36310				; MOVAC
K37164:	INCB	K36211
	ADD	#40, K36212			; MANPS += 32.
	MOV	#K37662, R3
	DECB	(R3)
	BEQ	K37212
	JMP	K25276				; => ENDVC
K37212:	MOV	#K47606, R2			; FALLC
	JMP	K52152				; => STL52

; HITJP procedure
K37222:	MOV	#6, R1				; 6.
; HITJR:
K37226:	MOV	#ManBf+6, R3
	MOV	#6, R2
	MOV	#1, R5
K37242:	MOVB	(R3), R0			; <
	INCB	R0
	CMPB	R0, #310
	BHIS	K37262
	ADD	R2, R3
	SOB	R1, K37242			; repeat
	CLRB	R5
K37262:	DECB	R5
	INCB	R5
	RETURN

; HITJJ procedure
K37270:	CALL	K37222				; HITJP
	BNE	K37300
	RETURN
K37300:	POP	R3
	BR	K37212

; SLOPQ procedure
K37304:	POP	R1
	CMPB	ManBf+43., #7
	BEQ	K37520				; => NRNDN
	CMPB	ManBf+46., #7
	BEQ	K37520				; => NRNDN
	PUSH	R1
	MOVB	#5, R1
	CALL	K37226				; HITJR
	POP	R1
	TSTB	R5
	BEQ	K37352
	JMP	K55262				; => SETST
K37352:	MOVB	ManBf+36., R0
	INCB	R0
	CMPB	R0, #310			; 200.
	BHIS	K37372	;TODO
	JMP	K37412				; => NRNUP
K37372:	DECB	K36211
	SUB	#40, K36212			; MANPS
	CALL	K40726				; OFTOP
	BR	K37520				; => NRNDN

; NRNUP:
K37412:	CMPB	ManBf+45., #307			; 199.
	BLO	K37426
	JMP	K37520				; => NRNDN
K37426:	CMPB	ManBf+42., #307			; 199.
	BLO	K37442	;TODO
	JMP	K37520				; => NRNDN
K37442:	INCB	K36211
	ADD	#40, K36212			; MANPS += 32.
	CALL	K54212				; OFBOT
	PUSH	R1
	;
	CALL	PrepManBf
	CALL	K36220				; MANAR
	CALL	PrepDraBuf
	;
	CALL	K50274				; FLORQ
	POP	R1
	MOVB	#5, R0
	TSTB	R5
	BNE	K37520				; => NRNDN
	JMP	K37022				; => SETTT

; NRNDN:
K37520:	PUSH	R1
	RETURN

; RITEP:
K37524:	CALL	K36344				; EDGES
	CALL	K37304				; SLOPQ
	CALL	K36310				; MOVAC
	CALL	K41000				; LEGS
	bit	#P_KEY_UP, PpuKeys
	BEQ	K37636

; SETJP: Set Jump
K37556:	MOVB	#1, R0
	MOVB	R0, K33542			; set JUMP = 1
	MOVB	R0, K54510+2			; set (HIGHT+1)
	MOVB	#4, K37662			; set SPEED = 4
	MOV	#K36412, R3			; JMP1P -> (VECTN+1)
	MOV	#K47336, R2			; JUMPC -> (CHARN+1)									; (!!!)
	JMP	K55246				; => SETVC - set vectors

; SETFK: Set Fire
K37614:	MOVB	#5, K37662			; set SPEED = 5
	MOV	#K36576, R3			; FKIKS -> (VECTN+1)
	MOV	#K47336, R2			; JUMPC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NJUMP:
K37636:	bit	#P_KEY_FIRE, PpuKeys		; bit 4 fire ?
	bne	K37614				; => SETFK
	bit	#P_KEY_RIGHT, PpuKeys		; bit 0 ?
	BNE	K37656
	JMP	K55262				; => SETST
K37656:	JMP	K25276				; => ENDVC

K37662:	.WORD	0				; SPEED

; TPORT: Teleport to room (30.,24.)
K37664:	MOVB	#36, RoomX			; set RMAC = 30. room position
	MOVB	#30, RoomY			; set RMDN = 24. room level
	MOVB	#5, K36211			; set MAND = 5
	MOVB	#4, K36210			; set MANA = 4
	MOV	#244, K36212			; set MANPS = 164.
	MOV	#K72232-2, RoomAddr		; set (RM+1)
K37742:	jmp	InitRoom			; => INISC

; RITSC: go one room right
K37746:	MOV	RoomAddr, R3			; get RM+1
	CMPB	(R3), #101			; room type == $41 ?
	BEQ	K37664				; yes => TPORT teleport
	INCB	RoomX				; incr RMAC - one room right
	MOVB	#375, K36210			; set MANA = 253.
	MOV	K36212, R3			; get MANPS
	SUB	#40, R3
	MOV	#1, R2				; one room right
	JMP	K54262				; => PIGGS

; LEFSC: go one room left
K40012:	DECB	RoomX				; decr RMAC - one room left
	MOVB	#35, K36210			; set MANA = 29.
	MOV	K36212, R3			; get MANPS
	ADD	#40, R3				; +32.
	MOV	#177777, R2			; one room left
	JMP	K54262				; => PIGGS

; LEFTP: - Vector for (VECTN+1)
K40044:	CALL	K36344				; EDGES
	CALL	K37304				; SLOPQ
	CALL	K36310				; MOVAC
	CALL	K41000				; LEGS
	MOV	#K17200, R3			; BIKER addr
	MOVB	(R3), R0
	INCB	R0
	BEQ	K40230				; => NESCP
	INCB	R0
	BEQ	K40230				; => NESCP
	DECB	(R3)
	BEQ	K40112
	JMP	K25276				; => ENDVC
K40112:	MOV	#21, R1				; 17.
	MOV	#K40164, R2			; " EXCELLENT VALUE "
	mov	#BuffO+263., R3
	CALL	PrintOnBgr			; BUFOM - Draw string as tiles
	MOV	#22, R1				; 18. string length
	MOV	#K40205, R2			; " YOU HAVE ESCAPED "
	mov	#BuffO+359., R3
	CALL	PrintOnBgr			; BUFOM - Draw string as tiles
	MOVB	#310, K17200			; set BIKER
	JMP	K55262				; => SETST - end of game

K40164:	.ASCII	/@EXCELLENT@VALUE@/
K40205:	.ASCIZ	/@YOU@HAVE@ESCAPED@/

; NESCP:
K40230:	bit	#P_KEY_UP, PpuKeys
	BEQ	K40246
	JMP	K37556				; SETJP - set jump
K40246:	bit	#P_KEY_FIRE, PpuKeys		; bit 4 fire ?
	BEQ	K40260
	JMP	K37614
K40260:	bit	#P_KEY_LEFT, PpuKeys		; bit 1 left ?
	BNE	K40272
	JMP	K55262				; => SETST
K40272:	JMP	K25276				; => ENDVC

K40276:	.WORD	0				; GLIPS
K40300:	.BYTE	0				; GLIDN

; GLIDC: Glider 4x11 tiles

K40301:	.BYTE	377,377,377,377,105,106,107,110,111,112,216
	.BYTE	113,114,115,116,117,120,121,122,123,216,216
	.BYTE	124,125,126,127,130,131,132,133,134,135,216
	.BYTE	377,377,377,136,137,377,140,141,216,216,216
	.BYTE	000

; DRGLI procedure: Draw glider 4x11 tiles; R1 = addr in tile screen, R2 = GLIDC or NINDC
K40356:	MOV	#K40276, K47720			; GLIPS addr -> (HELP1+1)
	MOV	K40276, R3			; get GLIPS
	ADD	R1, R3
	MOV	#4, R1				; height = 4
	MOVB	#11., K01604			; width = 11.
	MOVB	K40300, K01607
	MOVB	K36210, R0			; get MANA
	SUB	#2, R0
	mov	#177777, bIsDrawBuf1		; set to draw to BuffO
	call	DrawObject			; DRWOB
K40426:	MOV	#K36212, K47720			; MANPS addr -> (HELP1+1)
	RETURN

; DRBIK procedure
K40436:	MOV	#K17202, K47720			; BIKPS addr -> (HELP1+1)
	MOV	K36212, R3			; get MANPS
	ADD	#76, R3
	MOV	R3, K17202			; set BIKPS
	ADD	R1, R3
	MOVB	#5, R1				; bike height (5.)
	MOVB	#11., K01604			; bike width (11.)
	MOVB	#12, K01607
	MOVB	K36210, R0			; get MANA
	SUB	#2, R0
	CALL	DrawObject			; DRWOB
	BR	K40426

K40520:	CMPB	K36210, #375			; MANA == 253. ?
	BNE	K40534
	JMP	K40012
K40534:	CALL	K36310				; MOVAC
	BIT	#P_KEY_FIRE, PpuKeys
	BNE	K40564
	DECB	K37662
	BEQ	K40564
	JMP	K25276
K40564:	MOVB	#1, R0
	JMP	K36510

K40574:	.WORD	0

; BIKEP: ??? - Vector for (VECTN+1)
K40576:	CMPB	K36210, #375			; MANA == 253. ?
	BNE	K40612
	JMP	K40012
K40612:	CALL	K36310				; MOVAC
	RORB	K40574
	BHIS	K40626
	.WORD	005727				; TST #000261 ; XOR 1
K40626:	SEC
	ROLB	K40574
	BNE	K40576
	MOV	#K17273, R2			; ??? 11x5 tiles
	MOV	#BuffO, R1			; BUFFO Front tile screen address
	CALL	K40436				; DRBIK
	MOV	#K46162, R2
	MOV	#BuffD, R1			; BUFFD
	CALL	K40436				; DRBIK
	DECB	K37662
	BEQ	K40700
	JMP	K25276
K40700:	MOV	#K17204, R2			; BIKEC 11x5 tiles
	MOV	#BuffO, R1			; BUFFO Front tile screen address
	CALL	K40436				; DRBIK
	MOVB	#20, K17200			; set BIKER = 16.
	JMP	K55262				; => SETST game nearly completed
; OFTOP procedure
K40726:	MOVB	K36211, R0			; get MAND
	CMPB	R0, #371			; == 249. ?
	BEQ	K40742
	RETURN
K40742:	DECB	RoomY				; decr RMDN room level
	POP	R3
	ADD	#22, R0				; + 18.
	MOVB	R0, K36211			; set MAND
	MOV	K36212, R3			; get MANPS
	ADD	#1100, R3			; + 576.
	MOV	#177740, R2			; up one level
	JMP	K54262				; => PIGGS



;	; (!!!) WARNING
;	.if NE 41000-.
;	.error Addresses (41000) not in place
;	.endc


; LEGS procedure
K41000:	MOVB	K46775, K01602			; swap legs in Nina tileset
	MOV	#233, R0
	XOR	R0, K01602
	MOVB	K01602, K46775

; Legs copy tiles from 4 legs positions
; advance legs
	ADD	#22, K41150+2			; + 18.
	MOVB	K41172, R0			; get LEGP
	INCB	R0
	CMPB	R0, #4				; == 4 ?
	BNE	K41144
	MOV	#K47030, K41150+2
	mov	#C_PPU_SOUND7, PpuComm		; step
	clr	R0
K41144:	movb	R0, K41172			; set LEGP
K41150:	mov	#000000, R3			;!!MUT-ARG!! (!!!) must be even addr
	mov	#K47006, R2			; fortunately leg addrs ARE even
	mov	#4, R1				; 18. leg tiles (9. words)
10$:	mov	(R3)+, (R2)+			; <
	mov	(R3)+, (R2)+			; <
	sob	R1, 10$				; repeat
	mov	(R3)+, (R2)+
	return

K41172:	.byte	0				; LEGS
	.byte	0				; was FFCOL (K41173)
	.byte	0				; was FFCOL+1
K41175:	.BYTE	0				; TMPNC


; Foreground tiles
@include S2TILF.MAC

;K46162:
@include S24C72.MAC


; object buffer - copy background tiles here
; 050110
ManBf:	.blkb	60				; MANBF

;
; CRUTP: ??? - Vector for (VECTN+1)
K50170:	CALL	K50274				; FLORQ
	BNE	K50336
	MOV	K36212, R3			; get MANPS
	mov	#BuffO+34., R2
	CALL	K55630				; LFEDQ
	ADD	R2, R3
	MOV	#000002, R1
	TSTB	(R3)
	BNE	K50230
	CALL	Decen				; DECEN
K50230:	INCB	K36211
	MOV	K36212, R3			; get MANPS
	ADD	#40, R3
	MOV	R3, K36212			; set MANPS
	mov	#BuffO+34., R2
	CALL	K55630				; LFEDQ
	ADD	R2, R3
	TSTB	(R3)
	BEQ	K50272
	JMP	K55262				; => SETST
K50272:	BR	K50446				; => SINK

; FLORQ procedure
K50274:	MOV	#ManBf+53, R3
	MOV	#1, R5
	MOV	#4, R1
K50310:	MOVB	(R3), R0
	INCB	R0
	CMPB	R0, #310
	BHIS	K50332
	INC	R3
	SOB	R1, K50310			; repeat
	DECB	R5
	RETURN
K50332:	INCB	R5
	RETURN

K50336:	mov	#BuffO+34., R2
	CMPB	K36211, #377
	BPL	K50356
	mov	#BuffO+194., R2
K50356:	CALL	K55630				; LFEDQ
	MOV	K36212, R3			; get MANPS
	ADD	R2, R3
	TSTB	(R3)
	BEQ	K50446				; => SINK
	bit	#P_KEY_FIRE, PpuKeys
	beq	K50430
	MOVB	#1, K37662			; set SPEED = 1
	MOV	#K50624, R3			; CRKIP -> (VECTN+1)
	MOV	#K47140, R2			; CRKIC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NKIKK:
K50430:	bit	#P_KEY_DOWN, PpuKeys
	BNE	K50446
	JMP	K55262				; => SETST

; SINK:
K50446:	bit	#P_KEY_LEFT, PpuKeys
	BEQ	K50536
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BEQ	K50514				; 0 => CRRT
	CALL	K50572				; SWIMQ
	; was energy decrease under water - removed
	MOV	#K47264, R2			; SWIMC -> (CHARN+1)
	MOV	#K55644, R3			; SWILP -> (VECTN+1)
	JMP	K55246				; => SETVC - set vectors

; CRRT:
K50514:	MOVB	R0, K36264			; set DIR = 0
	JMP	K25276				; => ENDVC

; CLRT:
K50524:	INCB	R0				; 1.
	MOVB	R0, K36264			; set DIR = 1
	JMP	K25276				; => ENDVC

; NSWL:
K50536:	bit	#P_KEY_RIGHT, PpuKeys		; bit 0 ?
	BEQ	K50620				; => NSWR
	MOVB	K36264, R0			; get DIR
	BEQ	K50524				; 0 => CLRT
	CALL	K50572				; SWIMQ
	MOV	#K47264, R2			; SWIMC -> (CHARN+1)
	MOV	#K55466, R3			; SWIRP -> (VECTN+1)
	JMP	K55246				; => SETVC - set vectors

; SWIMQ:
K50572:	MOV	K36212, R3			; get MANPS
	mov	#BuffO+130., R2
	CALL	K55630				; LFEDQ
	ADD	R2, R3
	TSTB	(R3)
	BNE	K50616
	RETURN
K50616:	TST	(SP)+
; NSWR:
K50620:	JMP	K25276				; => ENDVC

; CRKIP:
K50624:	TSTB	K37662				; check SPEED
	BEQ	K50722
	MOVB	ManBf+36., R0
	INCB	R0
	BEQ	20$
	mov	#BuffG1+192., R2
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BNE	10$
	mov	#BuffG1+197., R2
10$:	CALL	K51646				; HITGQ
20$:	MOVB	ManBf+24., R0
	INCB	R0
	BEQ	K50722
	mov	#BuffG1+128., R2
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BNE	30$
	mov	#BuffG1+133., R2
30$:	CALL	K51646				; HITGQ
K50722:	CLRB	K37662
	bit	#P_KEY_FIRE, PpuKeys
	BEQ	K50744
	JMP	K25276
K50744:	CLRB	K33542				; clear JUMP
	MOV	#K50170, R3			; CRUTP -> (VECTN+1)
	MOV	#K47212, R2			; CRUTC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors


K50764:	.ASCII	/STASH SEARCHED/

; search stash
K51002:	DECB	K37662
	BEQ	K51014
	JMP	K25276
K51014:	MOV	K23746, R3			; get NERST
	MOVB	(R3), K23750			; -> TEMPN -> save first item
	; scroll items in the box
	MOV	#5, R1
K51030:	MOVB	1(R3), R0
	MOVB	R0, (R3)+
	CMPB	R0, #3				; empty item?
	BEQ	K51046
	SOB	R1, K51030			; repeat
	; all were scrolled
K51046:	DEC	R3
	CMPB	K23750, #4			; TEMPN == 4 ? first item was 'tape'?
	BNE	K51150
	; increase tapes count
	movb	#3, (R3)			; infinite tapes BUG FIX - set last item as 'empty'
	inc	K51142
	mov	K51142, R2			; where to print
	MOV	#TapesCount, R3			; TAPCT address
	INCB	(R3)
	CALL	Random				; Get random number
	BIC	#177776, R0
	ADD	#45, R0
	MOVB	R0, -(R3)			; set random 'tape' character to print
	MOV	#1, R1				; 1.
	CALL	PrintStr			; PRINT string
	MOV	#144, R1			; 100.
	CALL	L10244				; MONUP
	JMP	K55262				; set 'stand up' for Nina

K51142:		.word	0				; tapes print position
		.byte	0				; character of 'tape' to print (choosen randomly from 'tapes' chars)
TapesCount:	.byte	0				; TAPCT - tapes held

K11770:	.WORD	000				; CONQU

K51150:	CLR	R1
	TSTB	K24762
	BNE	K51164
	MOV	#200, R1
K51164:	MOVB	K33464, R0			; get HELD value
	BNE	K51200
	MOV	#3, R0
	CLR	R1
K51200:	BISB	R1, R0
	MOVB	R0, (R3)
	TSTB	R1
	BEQ	K51216
	MOVB	#1, K24762
K51216:	MOVB	K23750, R0			; get TEMPN
	BPL	K51300
	BIC	#177600, R0			; 0..177
	PUSH	R0
K51246:	MOV	#K50764, R3			; "STASH SEARCHED"
	MOV	#16, R1				; 14. string length
	MOV	#050146, R2			; screen coords
	CALL	PrintStr			; PRINT string "STASH SEARCHED"
	POP	R0
K51300:	CMPB	R0, #3
	BNE	K51310
	CLR	R0
K51310:	MOVB	R0, K33464			; clear HELD value
	CALL	DrawHeld			; HLDOD
	JMP	K55262

; FIREP:
K51324:	MOVB	ManBf+14, R0
	INCB	R0
	BEQ	K51620
	TSTB	K33464				; check HELD value
	BEQ	K51566

; HELD value != 0
K51342:	MOVB	K36264, R0			; get DIR
	MOV	#5, R1
	MOVB	#10, K01604
	MOV	#105, R2
	DECB	R0
	BEQ	K51406
	MOV	#0, R1
	MOVB	#4, K01604
	MOV	#100, R2
K51406:	MOVB	K36210, R0			; get MANA
	ADD	R1, R0
	MOV	K36212, R3			; get MANPS
	ADD	R2, R3
	MOV	R3, K01610
	MOVB	K01610, K33471
	MOVB	K01611, K33472
	MOVB	R0, K33470
	MOVB	K36211, R0
	ADD	#2, R0
	MOVB	R0, K33467
	MOVB	K33464, R0			; get HELD value
	ASL	R0
	ADD	#320, R0
	MOVB	R0, K33466			; MISL1 - Ninja object
	CLR	R0
	MOVB	R0, K33464			; set HELD value
	CALL	DrawHeld			; HLDOD
	MOVB	K01604, R0
	MOVB	R0, K33473
	MOVB	R0, K33474
	MOV	#K33474, R3
	bit	#P_KEY_UP, PpuKeys
	bne	K51556
	bit	#P_KEY_DOWN, PpuKeys
	beq	K51620
	INCB	(R3)
K51556:	INCB	(R3)
	CLRB	K37662
	BR	K51630
K51566:	TSTB	K37662
	BEQ	K51620
	mov	#BuffG1+32., R2
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BNE	10$
	mov	#BuffG1+37., R2
10$:	CALL	K51646				; HITGQ
K51620:	CLRB	K37662
K51630:	bit	#P_KEY_FIRE, PpuKeys
	BNE	K51642
	JMP	K55262
K51642:	JMP	K25276

; HITGQ procedure
K51646:	MOV	K36212, R3			; get MANPS
	ADD	R2, R3
	MOVB	(R3), R0
	INCB	R0
	BEQ	K51702
	MOVB	#1, R0
K51666:	MOVB	R0, K26672			; set GDHIT = 1
	MOVB	#1, K37662			; set SPEED = 1
	RETURN
K51702:	MOVB	1100(R3), R0
	INCB	R0
	BNE	K51714
	RETURN
K51714:	MOVB	#2, R0
	BR	K51666				; => LE234

; KICKP:
K51722:	MOVB	#2, K37662			; set SPEED = 2
	MOV	#K51744, R3			; KIKHP -> (VECTN+1)
	MOV	#K47410, R2			; KICKC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; KIKHP: ??? - Vector for (VECTN+1)
K51744:	MOV	#K37662, R3
	DECB	(R3)
	BNE	K51770
	MOV	#K52030, R3			; KIK2P -> (VECTN+1)
	MOV	#K47336, R2			; JUMPC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors
K51770:	MOVB	ManBf+7, R0
	INCB	R0
	BEQ	K52024
	mov	#BuffG1+33., R2
	MOVB	K36264, R0			; get DIR
	DECB	R0
	BNE	10$
	mov	#BuffG1+36., R2
10$:	CALL	K51646				; HITGQ
K52024:	JMP	K25276

; KIK2P: ??? - Vector for (VECTN+1)
K52030:	JMP	K55262				; => SETST


; RESTP procedure
K52036:	dec	(PC)+
	.word	2
	ble	10$
	return
10$:	mov	#2, K52036+2			; to slow down energy increase
	jmp	EnergyUp


; STANP: Ninja standing - Vector for (VECTN+1)
K52120:	CALL	K52036				; RESTP
	CALL	K50274				; FLORQ
	BNE	K52162
	MOV	#K47606, R2			; -> (CHARN+1)
	MOV	#1, R0
	MOV	R0, K54510+2			; set (HIGHT+1)
	MOVB	R0, K33542			; set JUMP
K52152:	MOV	#K54302, R3			; LEP5P -> (VECTN+1)
	JMP	K55246				; => SETVC - set vectors
K52162:	MOVB	K17200, R0			; get BIKER
	CMPB	R0, #20				; == 16. ?
K52172:	BNE	K52200
	JMP	K53066
K52200:	CMPB	R0, #310			; == 200. ?
	BNE	K52212
	JMP	Completed			; yes => COMPL
K52212:	bit	#P_KEY_FIRE, PpuKeys
	bne	K52230
	jmp	K53042				; => NFIRE

; Fire key; Console check
K52230:	MOVB	ManBf+24, R0			; get (MANBF+20.)
	INCB	R0
	BNE	K52244
	JMP	K52772				; no terminal => NCONU
K52244:	MOV	K36212, R3			; get MANPS
	add	#BuffO+98., R3
	CMPB	(R3), #212			; == 138. ?
	beq	UseTerminal
	JMP	K52772				; no terminal no => NCONU

; Console: check for LIFTSWAP or FENSWAP or CODEROP
; we need to stop changing console until all buttons up
UseTerminal:
	tst	#000000
	beq	10$
	jmp	K25276
10$:	inc	UseTerminal+2
	mov	#C_PPU_SOUND4, PpuComm
	MOV	RoomAddr, R3			; get (RM+1)
	CMPB	(R3), #075			; room type == $3D ?
	BEQ	K52446				; yes => K2DAQ
	CMPB	(R3), #115			; room type == $4D ?
	BEQ	K52402				; yes => KODAQ

; NSEEC:
; lift control from console
K52312:	MOVB	K60610, K01602			; get LFT1
	MOV	#356, R0
	XOR	R0, K01602			; XOR 238.
	MOVB	K01602, K60610			; set LFT1
	COMB	K60677				; invert LFT3
	MOV	#K52702, R3			; " LIFT IS DOWN "
	MOVB	K60677, R0			; get LFT3
	INCB	R0
	BEQ	K52362				; => BUTCR
	MOV	#K52720, R3			; "  LIFT IS UP  "
; BUTCR:
K52362:	MOV	#16, R1				; 14. string length
	MOV	#050146, R2			; screen coords
	CALL	PrintStr			; PRINT string
	JMP	K25276

; KODAQ: Console, room type == $4D - room right to rocket
K52402:	MOVB	K13224+2, R0			; get (DRFNT+1)
	INCB	R0
	BEQ	K52312
	MOV	#K31222, R3			; FENRM+1
	MOVB	(R3), R5
	MOV	#21, R0				; 17.
	XOR	R0, R5
	MOVB	R5, (R3)			; set (FENRM+1)
	MOV	#K52754, R3			; " FENCE IS OFF "
	INCB	R5
	BEQ	K52362				; => BUTCR
	MOV	#K52736, R3			; "  FENCE IS ON "
	BR	K52362				; => BUTCR


; K2DAQ: Console, room type == $3D - room left to rocket
; rocket launch 
K52446:	; was it already launched?
	tst	RocketLaunched
	beq	10$
	jmp	K25276				; continue 
	; 
10$:	mov	#050146, R2			; screen coords
	mov	#16, R1				; 14. string length
	movb	TapesCount, R0
	bne	20$
	mov	#K52630, R3			; CODE NEEDED
	call	PrintStr
	br	99$
20$:	cmpb	R0, #C_TAPES_NEEDED
	bhis	30$
	mov	#K52664, R3			; CODE REJECTED
	call	PrintStr
	br	99$
30$:	mov	#K52646, R3			; CODE ACCEPTED
	call	PrintStr
	call	RocketLaunch
	call	L15506				; add some money (500.)
99$:	jmp	K25276


K52630:	.ASCII	/ CODE  NEEDED /
K52646:	.ASCII	/CODE  ACCEPTED/
K52664:	.ASCII	/CODE  REJECTED/

K52702:	.ASCII	/ LIFT IS DOWN /
K52720:	.ASCII	/  LIFT IS UP  /
K52736:	.ASCII	/  FENCE IS ON /
K52754:	.ASCII	/ FENCE IS OFF /


; NCONU:
K52772:	TSTB	K33465				; check NEAR
	BEQ	K53020				; 0 => MAZZ1
	MOV	#2, R0				; 2. -> SPEED
	MOV	#K47212, R2			; CRUTC -> (CHARN+1)
	MOV	#K51002, R3			; TAKEP -> (VECTN+1)
	JMP	K55242				; => SETSP - set SPEED and vectors

; MAZZ1:
K53020:	MOVB	#1, K37662			; set SPEED = 1
	MOV	#K51324, R3			; FIREP -> (VECTN+1)
	MOV	#K46704, R2			; PUNCC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NFIRE: Check left direction
K53042:	bit	#P_KEY_LEFT, PpuKeys		; bit 1 left ?
	BEQ	K53106				; no => NLEFT
	TSTB	K36264				; check DIR
	BEQ	K53066
	DECB	K36264				; decrement DIR
	JMP	K25276				; => ENDVC

; LOK:
K53066:	CALL	K53612				; SETLG
	MOV	#K40044, R3			; LEFTP -> (VECTN+1)
	MOV	#K46756, R2			; RUNC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NLEFT: Check down direction
; LIFT DOWN start
K53106:	bit	#P_KEY_DOWN, PpuKeys		; bit 2 ? down
	BEQ	K53300				; no => NDOWN
	; replace bugged lift down check
	mov	K36212, R0			; MANPS
	movb	7.*32.+BuffB(R0), R1
	cmpb	R1, #324			; left lift tile?
	bne	K53166				; nope, it's not lift
	movb	8.*32.+BuffB(R0), R1
	cmpb	R1, #10				; blue stones tile under?
	bne	K53166				; nope, it can be a lift, but we can't go down
; bugged (classic ZX bug)
;	MOVB	ManBf+52, R0			; get (MANBF+42.)
;	TSTB	K36264				; check DIR
;	BEQ	K53132
;	MOVB	ManBf+57, R0			; get (MANBF+47.)
; FEGJB:
;K53132:	CMPB	R0, #324			; == 212. ?
;	BNE	K53166				; no => NLFTD
;	movb	BuffB+549., R0
;	CMPB	R0, #10				; == 10. ?
;	BNE	K53166
	CALL	L10300				; MONYP - Print MONEY
	MOV	#K54562, R3			; LIFTD address
	JMP	K55252				; => SETV2 - set vector

; NLFTD:
K53166:	MOVB	ManBf+54, R0
	TSTB	K36264				; check DIR
	BEQ	K53204
	MOVB	ManBf+55, R0			; ???  get (MANBF+44.)
K53204:	CMPB	R0, #54				; == 44. ?
	BEQ	K53240				; yes => SETL2
	CMPB	R0, #45				; == 37. ?
	BEQ	K53240				; yes => SETL2
	CMPB	R0, #11				; == 9. ?
	BEQ	K53240				; yes => SETL2
	CMPB	R0, #5				; == 5 ?
	BEQ	K53240				; yes => SETL2
	JMP	K50744				; => SETCR

; SETL2:
K53240:	MOV	#K53646, R3			; LADDP address
	MOV	#K46632, R2			; LADDC address
	MOV	R2, K36276+2
	MOV	R3, K25272+2			; set JMP address
	JMP	K54172				; => ONTLD

; SETLD:
K53264:	MOV	#K53646, R3			; LADDP -> (VECTN+1)
	MOV	#K46632, R2			; LADDC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NDOWN: Check right direction
K53300:	bit	#P_KEY_RIGHT, PpuKeys		; bit 0 ? right
	BEQ	K53352				; no => NRITE
	MOVB	K36264, R0			; get DIR
	CMPB	R0, #1
	BEQ	K53332
	INCB	R0
	MOVB	R0, K36264			; set DIR
	JMP	K25276				; => ENDVC

; ROK:
K53332:	CALL	K53612				; SETLG
	MOV	#K37524, R3			; RITEP -> (VECTN+1)
	MOV	#K46756, R2			; RUNC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; NRITE:
K53352:	bit	#P_KEY_UP, PpuKeys		; bit 3 ? kick
	BEQ	K53606				; no => NKICK
	TSTB	K36264				; check DIR
	BNE	K53440				; => NPOSR
	MOV	K36212, R3			; get MANPS
	add	#BuffO+64., R3
	CMPB	(R3), #142			; == 98. ?
	BNE	K53440				; no => NPOSR
	MOVB	#376, K17200			; set BIKER = 254.
	MOV	#K40576, R3			; BIKEP -> (VECTN+1)
	MOV	#K46244, R2			; BIKNC -> (CHARN+1)
	MOVB	#375, K17200			; set BIKER = 253.
	MOVB	#155, R0			; 109. -> SPEED
	JMP	K55242				; => SETSP - set SPEED and vectors

; NPOSR:
K53440:	MOVB	ManBf+52, R0			; get (MANBF+42.)
	TSTB	K36264				; check DIR
	BEQ	K53456
	MOVB	ManBf+57, R0			; get (MANBF+47.)
K53456:	CMPB	R0, #324			; == 212. ?
	BNE	K53512				; no => NLFTU
	movb	BuffB+549., R0			; get (BUFFB+549.)
	CMPB	R0, #10				; == 8. ?
	BEQ	K53512				; yes => NLFTU
	CALL	L10300				; MONYP - Print MONEY
	MOV	#K54774, R3			; LIFTU address
	JMP	K55252				; => SETV2 - set vector

; NLFTU:
K53512:	MOVB	ManBf+46, R0			; get (MANBF+38.)
	TSTB	K36264				; check DIR
	BEQ	K53530
	MOVB	ManBf+47, R0			; get (MANBF+39.)
K53530:	CMPB	R0, #11				; == 9. ?
	BNE	K53542
K53536:	JMP	K53264				; => SETLD
K53542:	CMPB	R0, #5				; == 5. ?
	BEQ	K53536				; => SETLD
	CMPB	R0, #45				; == 37. ?
	BEQ	K53536				; => SETLD
	CMPB	R0, #54				; == 44. ?
	BEQ	K53536				; => SETLD
	CMPB	R0, #20				; == 16. ?
	BEQ	K53536				; => SETLD
	MOV	#K51722, R3			; KICKP -> (VECTN+1)
	MOV	#K47336, R2			; JUMPC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors
; NCICK:
K53606:	JMP	K25276				; => ENDVC

; SETLG procedure
K53612:	MOV	#K47030, R3			; LEG1 address
	MOV	R3, K41150+2
	MOV	#K47006, R2
	MOV	#11, R1				; 18. (9 words)
10$:	mov	(R3)+, (R2)+			; <
	sob	R1, 10$				; repeat
	CLRB	K41172				; set LEGP = 0
	RETURN

; LADDP:
K53646:	MOVB	ManBf+46, R0			; get (MANBF+38.)
	TSTB	K36264				; check DIR
	BEQ	K53664
	MOVB	ManBf+47, R0			; get (MANBF+39.)
K53664:	CMPB	R0, #5				; == 5 ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #11				; == 9. ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #20				; == 16. ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #45				; == 37. ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #54				; == 44. ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #314			; == 204. ?
	BEQ	K53742				; yes => STLOL
	CMPB	R0, #377			; == 255. ?
	BEQ	K53742				; yes => STLOL
	JMP	K55262				; => SETST

; STLOL:
K53742:	bit	#P_KEY_RIGHT, PpuKeys
	BEQ	K53764				; no => NTOFR
	MOVB	#1, K36264			; set DIR = 1
	BR	K53776				; => OFLDQ

; NTOFR:
K53764:	bit	#P_KEY_LEFT, PpuKeys
	BEQ	K54032				; no => NTOFL
	CLRB	K36264				; DIR = 0 left

; OFLDQ:
K53776:	CMPB	ManBf+37., #307			; (MANBF+37.) compare to 199.
	BHIS	K54026				; => ENDVC
	MOVB	ManBf+43., R0			; get (MANBF+43.)
	INCB	R0
	CMPB	R0, #307			; compare to 199.
	BLO	K54026				; => ENDVC
K54022:	JMP	K55262				; => SETST
K54026:	JMP	K25276				; => ENDVC

; NTOFL:
K54032:	bit	#P_KEY_UP, PpuKeys		; bit 3 ?
	BEQ	K54134				; no => NUPL
	MOVB	K36211, R0			; get MAND
	DECB	R0
	BMI	K54076				; => LCLUY
	MOV	K36212, R3			; get MANPS
	add	#BuffB-30., R3			; + <BUFFB-30.>
	MOVB	(R3), R0
	CMPB	R0, #314			; == 204. ?
	BEQ	K54076				; yes => LCLUY
	CMPB	R0, #307			; compare to 199.
	BHIS	K54026				; => ENDVC

; LCLUY:
K54076:	CALL	K40726				; OFTOP
	DECB	K36211
	SUB	#40, K36212			; MANPS
; NXRNG:
K54114:	RORB	K36264				; DIR
	BHIS	K54124
	.WORD	005727				; TST #000261 or XOR 1
K54124:	SEC
	ROLB	K36264				; DIR
	BR	K54026				; => ENDVC
K54134:	bit	#P_KEY_DOWN, PpuKeys
	BEQ	K54026				; => ENDVC
	MOVB	ManBf+44., R0
	INCB	R0
	CMPB	R0, #307
	BHIS	K54022
	MOVB	ManBf+45., R0
	INCB	R0
	CMPB	R0, #307
	BHIS	K54022
K54172:	CALL	K54212				; OFBOT
	INCB	K36211
	ADD	#40, K36212			; MANPS
	BR	K54114
; OFBOT procedure
K54212:	MOVB	K36211, R0
	CMPB	R0, #13				; == 11. ?
	BEQ	K54226
	RETURN
K54226:	MOV	#RoomY, R3			; RMDN addr
	INCB	(R3)				; down one level
	POP	R3
	SUB	#21, R0
	MOVB	R0, K36211
	MOV	K36212, R3			; get MANPS
	SUB	#1040, R3
	MOV	#40, R2				; down one level for (RM+1)

; PIGGS:
K54262:	MOV	R3, K36212			; set MANPS
	add	R2, RoomAddr			; (RM+1) += R2
	jmp	InitRoom			; => INISC

; LEP5P:
K54302:	CALL	K54212				; OFBOT
	CALL	K50274				; FLORQ
	BEQ	K54530				; => HJRRF
	TSTB	K33540				; check DEAD
	BEQ	K54510				; 0=alive => HIGHT
; Dead
	MOV	#24, R1				; 20.
	MOV	#K54440, R2			; " MISSION TERMINATED "
	MOVB	K33540, R0			; get DEAD
	DECB	R0
	BNE	K54346				; => TIMMY
	MOV	#K54464, R2			; "  MISSION FAILURE  "
; TIMMY:
K54346:	mov	#BuffO+262., R3
	CALL	PrintOnBgr			; BUFOM - Draw string as tiles
	MOVB	K17200, R0			; get BIKER
	CMPB	R0, #375			; == 253. ?
	BNE	10$				; no => ALRTD
	MOV	#K17204, R2			; BIKEC
	MOV	#BuffO, R1			; BUFFO Front tile screen address
	CALL	K40436				; DRBIK
; ALRTD:
10$:	MOV	#K46162, R2			; NINDC address
	MOV	#BuffD, R1			; BUFFD address
	CALL	K40436				; DRBIK
	MOV	#K47534, R2			; DEDNC dead Ninja tiles -> (CHARN+1)
	MOV	#K55224, R3			; DIING -> (VECTN+1)
	MOVB	#40, R0				; -> SPEED
	JMP	K55242				; => SETSP - set SPEED and vectors
;
K54440:	.ASCII	/@MISSION@TERMINATED@/
K54464:	.ASCII	/@@MISSION@@FAILURE@@/

; HIGHT:
; dropped on the floor
K54510:	MOV	#1, R1				; 1.
	CALL	Decen				; DECEN
	mov	#C_PPU_SOUND3, PpuComm
	JMP	K50744				; => SETCR

; HJRRF:
K54530:	MOV	#K54510+2, R3			; HIGHT+1 addr
	CMPB	#372, (R3)			; == 250. ?
	BEQ	K54544				; yes => NOEL
	INCB	(R3)

; NOEL:
K54544:	INCB	K36211				; increment MAND
	ADD	#40, K36212			; MANPS
	JMP	K25276				; => ENDVC

; LIFTD: lift down
K54562:	MOVB	#021, K60610			; set LFT1 = 17.
	CLRB	K60677				; set LFT3 = 0 UP
	CALL	K52036				; RESTP
	CALL	K54212				; OFBOT
	INCB	K36211				; increment MAND
	MOV	K36212, R3			; get MANPS
	ADD	#40, R3				; + 32.
	MOV	R3, K36212			; set MANPS
	add	#BuffB+192., R3
	; set wall tiles above lift (update buffD WITH 1 (!))
	mov	#6, R1
10$:	movb	#1, -1100(R3)			; update BuffD WITH 1 (is enough)
	movb	#10, (R3)+
	sob	R1, 10$				; repeat
	CMPB	K36211, #13			; MAND == 11. ?
	BEQ	K54710				; yes => JHGYG
	ADD	#32, R3				; + 26.
	; draw lift if it's not already arrived
	mov	#K70602, R2
	mov	#6, R1				; 6.
20$:	movb	#1, -1100(R3)			; update BuffD WITH 1 (is enough)
	movb	(R2)+, (R3)+			; <
	sob	R1, 20$				; repeat

; JHGYG:
K54710:	MOV	#K54774, R3			; LIFTU address
	bit	#P_KEY_UP, PpuKeys
	beq	K54732
	JMP	K55252				; => SETV2 - set vector
K54732:	MOVB	#177777, R0
	MOVB	R0, K60610			; set LFT1 = 255.
	MOVB	R0, K60677			; set LFT3 = 255. DOWN
	MOV	K36212, R3			; get MANPS
	add	#BuffB+256., R3
	CMPB	(R3), #372
	BEQ	K54770
	JMP	K25276				; => ENDVC
K54770:	JMP	K50744				; => SETCR

; LIFTU: lift up
K54774:	MOV	#177777, R0
	MOVB	R0, K60610			; set LFT1 = 255.
	MOVB	R0, K60677			; set LFT3 = 255. DOWN
	CALL	K52036				; RESTP
	CALL	K40726				; OFTOP
	DECB	K36211				; decrement MAND
	MOV	K36212, R3			; get MANPS
	SUB	#40, R3
	MOV	R3, K36212			; set MANPS
	CMPB	K36211, #13
	BEQ	K55134
	; draw lift on BuffB, set BuffD (to 2)
	add	#BuffB+224., R3			; lift addr
	MOV	#6, R1
	mov	#K70602, R2			; lift tiles addr
10$:	movb	#1, -1100(R3)			; update BuffD WITH 1 (is enough)
	movb	(R2)+, (R3)+
	sob	R1, 10$
	; test if not arrived
	CMPB	K36211, #12
	BEQ	K55134
	; then restore wall tiles under lift
	add	#32, R3
	mov	#6, R1
20$:	movb	#1, -1100(R3)			; update BuffD WITH 1 (is enough)
	movb	#10, (R3)+			; <
	sob	R1, 20$

; JHGY2:
K55134:	MOV	#K54562, R3			; LIFTD address
	bit	#P_KEY_DOWN, PpuKeys
	BNE	K55252				; yes => SETV2 - set vector
	MOVB	#21, K60610			; set LFT1 = 17.
	CLRB	K60677				; set LFT3 = 0 UP
	MOV	K36212, R3			; get MANPS
	add	#BuffB+191., R3
	CMPB	(R3), #10
	BEQ	K55206
	JMP	K25276				; => ENDVC
K55206:	DECB	K36211				; decrement MAND
	SUB	#40, K36212			; MANPS
	JMP	K55262

; DIING: Dying Ninja
K55224:	DECB	K37662				; decr SPEED
	BEQ	K55236
	JMP	K25276				; => ENDVC
K55236:	jmp	Finished

; SETSP: Set SPEED and vectors
K55242:	MOVB	R0, K37662			; set SPEED
; SETVC: Set vectors
K55246:	MOV	R2, K36276+2			; set (CHARN+1)
; SETV2: Set vector
K55252:	MOV	R3, K25272+2			; set (VECTN+1)
	JMP	K25276				; => ENDVC

; SETST: Set Standing
K55262:	CLRB	K33542				; clear JUMP
	MOV	#K52120, R3			; STANP -> (VECTN+1)
	MOV	#K46561, R2			; STANC -> (CHARN+1)
	JMP	K55246				; => SETVC - set vectors

; SWIRP: Swim - Vector for (VECTN+1)
K55466:	MOVB	K36210, R0			; get MANA
	CMPB	R0, #35				; == 29. ?
	BNE	K55504
	JMP	K37746				; => RITSC - go one room right
K55504:	CMPB	R0, #32				; == 26. ?
	BHIS	K55534				; => NCHK1
	MOV	K36212, R3			; get MANPS
	add	#BuffB+198., R3
	CMPB	(R3), #307
	BHIS	K55546				; => BLOW1
	MOVB	K36210, R0			; get MANA
; NCHK1:
K55534:	INCB	R0
	MOVB	R0, K36210			; set MANA
	INC	K36212				; increment MANPS
; BLOW1:
K55546:	CALL	K55736				; LEGSW
	bit	#P_KEY_RIGHT, PpuKeys
K55562:	BNE	K55570
	JMP	K50744				; => SETCR
K55570:	mov	#BuffO+98., R2			; BUFFO+98.
	CALL	K55630				; LFEDQ
	MOV	K36212, R3			; get MANPS
	ADD	R2, R3
	TSTB	(R3)
	BNE	K55624				; => NFLOT
	DECB	K36211				; decrement MAND
	SUB	#40, K36212			; MANPS -= 32.
; NFLOT:
K55624:	JMP	K25276				; => ENDVC

; LFEDQ Procedure: If MANA != 253., increment R2
K55630:	CMPB	K36210, #375			; MANA == 253. ?
	BNE	K55642				; no => return
	INC	R2
K55642:	RETURN

; SWILP:
K55644:	MOVB	K36210, R0			; get MANA
	CMPB	R0, #375
	BNE	K55662
	JMP	K40012				; go one room left
K55662:	CMPB	R0, #1
	ble	K55710				; already going out of screen, do not check furtheer
	mov	K36212, R3
	add	#BuffB+191., R3
	CMPB	(R3), #307
	BHIS	K55720
K55710:	DECB	K36210				; decrement MANA
	DEC	K36212				; decrement MANPS
K55720:	CALL	K55736				; LEGSW
	bit	#P_KEY_LEFT, PpuKeys
	BR	K55562				; => FLOTQ
; LEGSW procedure
K55736:	MOVB	K47313, K01602			; room number
	MOV	#7, R0
	XOR	R0, K01602			; FOOTC
	MOVB	K01602, K47313			; room number
	RETURN


; K55764 = RM0		Room sequences, 246. rooms
; K70632 = MAP		World map, 32x28 bytes
; K72572 = RMS		Room sequence addresses, 246. rooms
@include S2ROOM.MAC
K60677 = K60640 + 37				; LFT3 lift position byte: 377 = DOWN, 0 = UP

; GuardTiles:
@include S2SPRT.MAC

; NinaTiles
@include S2NINA.MAC

; GTBAK procedure
PrepManBf:
	; clear ManBf
	mov	#ManBf, R3			; MANBF
	mov	#60/4, R1
	mov	#177777, R2
10$:	mov	R2, (R3)+			; <
	mov	R2, (R3)+			; <
	sob	R1, 10$				; repeat
	; ask to draw to ManBf
	clr	bIsDrawBuf1			; (!) two bytes there
	return
; GTBK2 Procedure - restore drawing to BuffX
PrepDraBuf:
	mov	#177777, bIsDrawBuf1		; (!) two bytes there
	return

; MONUP procedure: MONEY up by R1
L10244:	MOV	#StrMoney+13, R3		; < address
	MOV	#6, R5				; 6.
	MOV	#72, R0				; 58.
L10260:	INCB	(R3)				; <
	CMPB	R0, (R3)
	BNE	L10276				; => PRMON
	MOVB	#60, (R3)			; '0'
	DEC	R3
	SOB	R5, L10260			; repeat
L10276:	SOB	R1, L10244			; repeat

; MONYP entry point: Print MONEY
L10300:	mov	#050146, R2			; screen coords
	mov	#16, R1				; size 14.
	mov	#StrMoney, R3			; " PAY $0000000 "
	jmp	PrintStr


; decrement energy, R1 - amount to decrease
Decen:	tst	#1				; changeable to 0 in secret room
	beq	99$				; nothing to decrease
	sub	R1, Energy
	bgt	90$
	; out of energy
	movb	#1, K33540			; set DEAD = 1
	clrb	Decen+2				; clear energy decrement
	clr	Energy
90$:	call	DrawEnergy
99$:	return


; COMPL game is completed
Completed:
	; TODO: pause a little
	; TODO: check for real completition?
	; all codes accepted etc?
Finished:
	clr	PpuKeys
10$:	bit	#P_KEY_FIRE, PpuKeys			; check FIRE
	beq	10$
	jmp	CoreStart			; FIN

; money up 500
L15506:	MOV	#000372, R1			; 250.
	CALL	L10244				; MONUP
	MOV	#000372, R1			; 250.
	JMP	L10244				; MONUP

L15646:	.WORD	0				; RMTIME


; tile screens 32x18 = 576. bytes
BuffD:	.blkb	1100			; BUFFD - Contact tile screen address
BuffB:	.blkb	1100			; BUFFB - Back tile screen address
BuffO:	.blkb	1100			; BUFFO - Front tile screen address
BuffN:	.blkb	1100			; BUFFN - Ninja tile screen address
BuffG1:	.blkb	1100			; BUFFG1 - Enemy 0 tile screen address
BuffG2:	.blkb	1100			; BUFFG2 - Enemy 1 tile screen address

; 043310 magic number addition replacement
CBuffsDiffA =: BuffD - 61014

EndOfCpu = .

	; (!!!) OVERFLOW WARNING
	.if LT 130000-.
	.error Main program exceeds its limits
	.endc

	.end	Start
